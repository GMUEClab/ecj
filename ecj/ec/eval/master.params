# Copyright 2006 by Sean Luke and George Mason University
# Licensed under the Academic Free License version 3.0
# See the file "LICENSE" for more information

# When eval.masterproblem is turned on, the system assumes
# use of the master/slave evaluator.
eval.masterproblem = ec.eval.MasterProblem

# Turning this on will provide synchronization
# information for debugging the master/slave evaluator
eval.masterproblem.debug-info = false

# How large should each slave's job queue be?  In the past this 
# had a significant effect on network performance, but it doesn't
# any more.  Now it mostly serves to allow you to send out a large
# number of children before getting any back, which mostly has (likely
# negative) effects on steady-state evolution.  Unless you have a special
# reason to, keep this at 1 for the time being until we add some new code
# which allows it to have an effect on.
eval.masterproblem.max-jobs-per-slave = 1

# How large should our job be?  If you're doing ordinary
# non-coevolutionary evolution, you can specify how many individuals
# should be placed into a job (maximum) and sent to the slave
# to be evaluated at one time, using the below parameter.
# If your individuals are small in size, this can significantly
# improve the network bandwidth.  If the individuals are large
# in size, it'll have no real effect.  Furthermore, if your
# slave is running in 'evolve' mode, this parameter will determine
# the maximum (and typical) size of the "population" the slave is
# evolving.  This works for both steady-state and generational evolution,
# but if you're doing coevolution, the job size is ignored -- instead
# the job will consist of the individuals to be coevolved together.
eval.masterproblem.job-size = 100

# This compresses the streams between the master and slaves.
# Compression at present is BROKEN and DOES NOT WORK RIGHT.
# This is because somewhere in JDK 1.5 Sun further broke their
# already broken zlib libraries, eliminating our ability to
# hack around them.  Until we get another zlib library up
# and running, don't use compression.
eval.compression=false

# This defines the socket port that the master listens in
# for incomoing Slaves to connect.
eval.master.port = 15000

# Change this to force whole Individuals to be returned by the
# Slave rather than just returning Fitnesses, plus whether or not the
# Individual was evaluated.  Returning a whole Individual is expensive
# over the network and should only be done if, for some reason, your
# Problem class modified the Individuals as it evaluates them.
eval.return-inds = false



# OPTIONAL SLAVE PARAMETERS

# Lets the slaves know that they're slaves.  Slaves should
# have different parameter files than masters.
# eval.i-am-slave = true

# Specifies the IP address of the master, for the Slaves
# to connect.  Slaves need to be told this in their
# parameter files.  The example below sets it to localhost,
# which is probably not what you want.
# eval.master.host = 127.0.0.1

# Specifies a slave's name for debugging purposes.  If this is not
# set (the default), then the system will use an approximately unique
# name constructed from the IP address and startup time of the
# slave.  Names don't have to be unique -- it's only for debugging.
# eval.slave-name = my-slave-name

# Specifies the mode the slave runs in.  If FALSE, the slave runs in
# 'regular' mode where it just evaluates the individuals and returns
# either the fitnesses or the whole individuals.  
