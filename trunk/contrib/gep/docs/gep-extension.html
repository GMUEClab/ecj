<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40"><head>


  
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">


  
  <link rel="File-List" href="./gep-extension_files/filelist.xml">

  



  
  

  <title>ECJ</title><!--[if gte mso 9]><xml> <o:DocumentProperties> <o:Author>Bob Orchard</o:Author> <o:LastAuthor>Bob Orchard</o:LastAuthor> <o:Revision>12</o:Revision> <o:TotalTime>157</o:TotalTime> <o:Created>2007-02-01T20:37:00Z</o:Created> <o:LastSaved>2007-02-02T15:38:00Z</o:LastSaved> <o:Pages>2</o:Pages> <o:Words>594</o:Words> <o:Characters>3386</o:Characters> <o:Company>National Research Council</o:Company> <o:Lines>28</o:Lines> <o:Paragraphs>6</o:Paragraphs> <o:CharactersWithSpaces>4158</o:CharactersWithSpaces> <o:Version>9.6926</o:Version> </o:DocumentProperties> </xml><![endif]--><style>
<!--
/* Font Definitions */
@font-face
{font-family:Helvetica;
panose-1:2 11 6 4 2 2 2 2 2 4;
mso-font-charset:0;
mso-generic-font-family:swiss;
mso-font-pitch:variable;
mso-font-signature:536902279 -2147483648 8 0 511 0;}
/* Style Definitions */
p.MsoNormal, li.MsoNormal, div.MsoNormal
{mso-style-parent:"";
margin:0in;
margin-bottom:.0001pt;
mso-pagination:widow-orphan;
font-size:12.0pt;
font-family:"Times New Roman";
mso-fareast-font-family:"Times New Roman";}
h1
{mso-style-next:Normal;
margin:0in;
margin-bottom:.0001pt;
mso-pagination:widow-orphan;
page-break-after:avoid;
mso-outline-level:1;
font-size:12.0pt;
font-family:"Times New Roman";
mso-font-kerning:0pt;
font-weight:bold;}
a:link, span.MsoHyperlink
{color:blue;
text-decoration:underline;
text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
{color:purple;
text-decoration:underline;
text-underline:single;}
p
{margin-right:0in;
mso-margin-top-alt:auto;
mso-margin-bottom-alt:auto;
margin-left:0in;
mso-pagination:widow-orphan;
font-size:12.0pt;
font-family:"Times New Roman";
mso-fareast-font-family:"Times New Roman";}
p.1Level, li.1Level, div.1Level
{mso-style-name:1Level;
mso-style-update:auto;
margin-top:0in;
margin-right:0in;
margin-bottom:0in;
margin-left:.25in;
margin-bottom:.0001pt;
text-indent:-.25in;
mso-pagination:none;
tab-stops:89.4pt;
mso-layout-grid-align:none;
text-autospace:none;
font-size:14.0pt;
mso-bidi-font-size:12.0pt;
font-family:Helvetica;
mso-fareast-font-family:"Times New Roman";
mso-bidi-font-family:"Times New Roman";
font-weight:bold;
mso-bidi-font-weight:normal;
font-style:italic;
mso-bidi-font-style:normal;}
@page Section1
{size:8.5in 11.0in;
margin:1.0in 1.25in 1.0in 1.25in;
mso-header-margin:.5in;
mso-footer-margin:.5in;
mso-paper-source:0;}
div.Section1
{page:Section1;}
-->
  </style><!--[if gte mso 9]><xml> <o:shapedefaults v:ext="edit" spidmax="1026"> <o:colormenu v:ext="edit" fillcolor="none"/> </o:shapedefaults></xml><![endif]--><!--[if gte mso 9]><xml> <o:shapelayout v:ext="edit"> <o:idmap v:ext="edit" data="1"/> </o:shapelayout></xml><![endif]--></head>
<body style="" lang="EN-US" link="blue" vlink="purple">


<div class="Section1 MsoNormal">
<table style="width: 100%;" border="0" cellpadding="0" width="100%">


  <tbody>


    <tr>


      <td style="padding: 0.75pt; background: darkblue none repeat scroll 0% 50%; -moz-background-clip: initial; -moz-background-origin: initial; -moz-background-inline-policy: initial; width: 100%;" width="100%">
      
      <p class="MsoNormal"><b><span style="font-size: 18pt; color: white;">ECJ</span></b>
      </p>


      </td>


    </tr>


  
  </tbody>
</table>


<p style="margin-bottom: 12pt;"><b>An Evolutionary
Computation and Genetic
Programming System</b></p>


<h1>Extension to support Gene Expression Programming (GEP)</h1>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p style="margin: 0in 0in 0.0001pt;">Bob Orchard
(bob.orchard@nrc.iit.gc.ca)</p>


<p class="MsoNormal">National Research Council of Canada</p>


<p class="MsoNormal">Institute for Information Technology</p>


<h1><br>


</h1>


<h1><a href="#What_is_GEP">What is Gene Expression
Programming?</a></h1>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<h1><a href="#How_to_use_GEP_in_ECJ">How Do I Use
GEP in the ECJ System? Some Simple Examples.</a></h1>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<h1><a href="#Some_examples">Some Other Examples</a></h1>


<h1><a href="#Function_Finding_Examples"><br>


</a></h1>


<div style="margin-left: 40px;">
<h1><a href="#Function_Finding_Examples">Function
Finding Examples</a></h1>


</div>


<h1 style="margin-left: 40px;"><a href="#Some_examples"><br>


Classification Examples</a></h1>


<div style="margin-left: 40px;"><br>


</div>


<h1 style="margin-left: 40px;"><a href="#Time_Series_Examples">Time
Series Examples</a></h1>


<div style="margin-left: 40px;"><br>


</div>


<h1 style="margin-left: 40px;"><a href="#Logical_Problem_Examples">Logical
Problem Examples</a></h1>


<br>


<h1><a href="#A_Detailed_Look_at_the_GEP_Parameter">A
Detailed Look at
the GEP Parameter File (gep.param)</a></h1>


<br>


<h1><a href="#Some_of_the_Implementation_Details">
Some of the Implementation Details</a></h1>


<h1>
<br>


</h1>


<div style="margin-left: 40px; font-weight: bold;"><a href="#ModsToExistingECJcode">Changes
to Existing ECJ code</a><br>


<br>


<a href="#AddingNewFunctions">Adding
New Math Functions and Fitness Functions</a></div>


<h1>
</h1>


<br>


<br>


<span style="font-family: &quot;Times New Roman&quot;;"></span>
<h1><a name="What_is_GEP">What is Gene Expression
Programming</a>?</h1>


<br>


<p class="MsoNormal"><span style="" lang="EN">There
are a number of
topics that fall under the general
category of Evolutionary Computing. These include Genetic Algorithms
(GA) and
Genetic Programs (GP). <b><span style="" lang="EN">Gene
Expression Programming</span></b><span style="" lang="EN">
(GEP) is a ‘new’ evolutionary algorithm (developed
by Cândida Ferreira) that
evolves computer programs in a way similar to GP. But the
representation of the
programs is more efficient and leads to less complex implementation of
the
genetic operators. The individuals of gene expression programming are
encoded
in linear chromosomes which are expressed or translated into expression
trees
when evaluation is required. Thus, in GEP, the genotype (the linear
chromosomes) and the phenotype (the expression trees) are different
entities
(both structurally and functionally).</span></span></p>


<br>


<p class="MsoNormal"><span style="" lang="EN">As
in nature,
the
linear chromosomes consist of the genetic material that is passed on
with
modification to the next generation. Therefore, in GEP, all the genetic
modifications take place in the chromosomes, and only the chromosomes
are
transmitted in the process of reproduction. After reproduction the new
chromosomes are expressed forming the body or expression trees (ETs).<br>


</span></p>


<br>


<p class="MsoNormal"><span style="" lang="EN">The
ETs are computer
programs evolved to solve a particular problem and are selected
according to
their capabilities in solving the problem at hand. With time,
populations of
such computer programs discover new traits and become better adapted to
a
particular selection environment (for instance, a set of experimental
results)
and, hopefully, a good solution evolves.<o:p></o:p></span></p>


<span style="font-family: &quot;Times New Roman&quot;;">
<br>


</span>
<p class="MsoNormal"><span style="" lang="EN">This
is variation of Genetic Programming&nbsp;and not a
‘new’ type
of evolutionary computing. However, due to the genotype/phenotype
representation and to the multigenic organization of GEP chromosomes,
this new
algorithm generally leads to better performance. It may also generate better solutions in many cases.<o:p></o:p></span></p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal"><span style="" lang="EN">For
all the
details of this new algorithm, see the seminal <a href="http://www.gene-expression-programming.com/webpapers/gep.pdf" title="http://www.gene-expression-programming.com/webpapers/gep.pdf" rel="nofollow">GEP paper</a> by Ferreira (published in
Complex Systems) where the
algorithm is fully described and applied to a set of problems,
including
symbolic regression, boolean concept learning, and cellular automata.<o:p></o:p></span></p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal"><span style="" lang="EN">Now
much of the
above is taken directly from the Wikipedia definition of GEP and as it
says, the
details can
be found in Ferreira’s paper and in much greater detail in
her excellent book, <i>Gene
Expression programming: mathematical modeling by an artificial
intelligence.</i>
2<sup>nd</sup> Edition. Springer-Verlag: 2006. ISBN
3-540-32796-7. There is
also a commercial implementation of the algorithm by the company
founded by
Ferreira, Gepsoft (<a href="http://www.gepsoft.com/">www.gepsoft.com</a>).
The
product is called GeneXproTools. You might also look at the
documentation
provided with the fully functioning (but limited) download of
GeneXproTools
to gain much more insight and detail about gep, or just view the short
tutorial
(<a href="http://www.gepsoft.com/tutorial002.htm">http://www.gepsoft.com/tutorial002.htm</a>).
<o:p></o:p></span></p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal"><span style="" lang="EN">The
intent of
this ECJ implementation of the gep algorithm is to provide a free, and
hopefully
useful and accurate implementation of the software, with most of the
major functionality. And, since the source code
is
provided, researchers and other interested parties can experiment with
ways to
enhance or improve some aspect of this approach to evolutionary
computing. </span></p>


<p class="MsoNormal">&nbsp;</p>


<span style="font-family: &quot;Times New Roman&quot;;"></span>
<h1><a name="How_to_use_GEP_in_ECJ">How
Do I Use GEP
in the ECJ System? Some Simple Examples.</a></h1>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal">One doesn’t need
to
understand the detailed implementation of
gep in ECJ to use the system but it is necessary to know about some
things so
that the appropriate parameters can be set and your data can be
processed.<br>


<br>


</p>


<div style="margin-left: 80px;"><span style="font-weight: bold; font-style: italic;">Please NOTE
that
the output from any examples in this documentation may be different
than the output you see when you execute the problem</span><span style="font-style: italic;">s</span>.
The code is changing and this can cause changes to the output even with
the same input (especially if code changes affect the way or order in which random
numbers are allocated).<br>


</div>


<p class="MsoNormal"><br>


</p>


<span style="font-family: &quot;Times New Roman&quot;;">
</span>
<p class="MsoNormal">You need to supply 3
things to run an
experiment: a <span style="font-weight: bold; font-style: italic;">parameter
file</span> that defines how to do the evolution, a very <span style="font-weight: bold; font-style: italic;">simple Java class</span>
(actually you don't even need to do any programming at all ... more
about that option later), and <span style="font-weight: bold; font-style: italic;">some
data</span> (the data can be in a file or encoded in your simple Java class).
We’ll start by
looking at a very simple problem, showing the simplest of parameter
files
and the minimal Java program. </p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal">The example is to
determine a model
(equation) that
satisfies the following set of data (stored in the file
test1.txt). The variables x and y are independent variables and z is
the dependent variable, so &nbsp;z = f(x,y).</p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal" style=""><code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">x,<span style="">&nbsp;&nbsp;&nbsp;&nbsp;
</span>y,<span style="">&nbsp;&nbsp;&nbsp;
</span>z<o:p></o:p></span></code></p>


<p class="MsoNormal" style=""><code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">0.5,<span style="">&nbsp;
</span>1.0,<span style="">&nbsp;
</span>1.25 <o:p></o:p></span></code></p>


<p class="MsoNormal" style=""><code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">1.0,<span style="">&nbsp;
</span>2.0,<span style="">&nbsp;
</span>3.0 <o:p></o:p></span></code></p>


<p class="MsoNormal" style=""><code><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;">2.0,<span style="">&nbsp;
</span>4.0,<span style="">&nbsp;
</span>8.0<o:p></o:p></span></code></p>


<p class="MsoNormal" style=""><span style="font-size: 10pt; font-family: &quot;Courier New&quot;;"><code>3.0,
12.0, 21.0</code><o:p></o:p></span></p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal">You might quickly see that
this is
‘perfect’ sample data for
the function z = x*x + y.&nbsp;Data files that are currently
supported are the so called CSV, comma
separated value, text files. NOTE: gzip'd files can also be used
directly.So if a file ends in .gz or .gzip we will handle the
uncompression of the file. For example in this case we could have
compressed test1.txt to create test1.txt.gz and identified the gzip'd
file rather than the .txt file in the parameter file (see below).</p><p class="MsoNormal"></p><p class="MsoNormal">Generally one will use either a
comma, a space or a tab to be the field separator. The example above uses a
comma. The first row of the file must identify
the independent and dependent variable names with the last column being
the
dependent variable. You’ll see later that for time series
problems there is another
file format that is used with ‘raw’ time series
data, but for most problems
the training data, when in a file, has this format. So here we have 3 columns
that identify the 2 independent variables <span style="font-style: italic;">x</span> and <span style="font-style: italic;">y</span> plus the
dependent variable <span style="font-style: italic;">z</span>.
There are 4 rows of numeric data that we will use as 'training' data
during the evolutionary process.&nbsp;<br>

<br>


</p>


<p class="MsoNormal">The parameter file that
tells the gep
system how to behave as it generates models and proceeds from
generation to generation is test1.param. It has the following
content:&nbsp;</p>


<br>


<p class="MsoNormal"><small><code>#
This
parameter file supports a simple test example to solve x^2 + y.<br>


#<br>


# The data (including variable names) is in the file test1.txt.<br>


<br>


# My parent:<br>


parent.0 =&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; ../../../gep/gep.params<br>


<br>


# Problem<br>


#===============================<br>


eval.problem = ec.app.gep.test1.test1<br>


<br>


# run for 100 generations, quit prematurely if I find something ideal<br>


generations =&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 100<br>


quit-on-run-complete =&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;true<br>


<br>


# ec.Subpopulation<br>


# ==============================<br>


<br>


# subpop size is 50 individuals<br>


pop.subpop.0.size =&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 50<br>


<br>


# ec.Species<br>


# ==============================<br>


<br>


gep.species.numgenes = 2<br>


gep.species.gene-headsize = 5<br>


gep.species.gene-linking-function = +<br>


<br>


# Problem type must be one of: functionfinding, classification,
timeseries, logical<br>


# Set default to be 'unknown' so user is forced to specify in the
problem params file <br>


gep.species.problemtype = functionfinding<br>


<br>


# specify the symbols ... functions and terminals (variables)<br>


#<br>


# the terminal symbols (variable names) will be obtained from the data
file (1st row)<br>


gep.species.symbolset.terminalfilename = ec/app/gep/test1/test1.txt<br>


# 4 functions + - * /&nbsp; are used in this problem<br>


gep.species.symbolset.functionsize = 4<br>


gep.species.symbolset.function.0 = Add<br>


gep.species.symbolset.function.1 = Sub<br>


gep.species.symbolset.function.2 = Mul<br>


gep.species.symbolset.function.3 = Div<br>


<br>


#&nbsp;Statistics<br>


# ==============================<br>


<br>


# output statistics to the file "test1.stat" in the directory<br>


# the run was started in<br>


stat =&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
ec.gep.GEPSimpleStatistics<br>


stat.file =&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;test1.stat</code></small></p>


<span style="font-family: monospace;"><br>


</span>
<p class="MsoNormal"><span style="" lang="EN">Let's
look at the
parameters in some
detail. First we see that the file references a parent file
(</span><small><code>../../../gep/gep.params</code></small><span style="" lang="EN">). This is the parameter file that holds all of the
default settings for a gep problem. You can over-ride any of the
settings in this file by including new values in your own param file
(in this case, test1.param). But your param file must reference this
file so that the settings that you are not concerned about are properly defined.
If you looked at the gep.params file you'd see the full set of
&nbsp;parameters that can be specified (more on this later). You'd
also see that it references the basic ecj param file as well. But for
now we're only concerned with the parameters that are set for this
simple example.&nbsp;</span></p>


<span style="font-family: &quot;Times New Roman&quot;;"><br>


</span>
<p class="MsoNormal">Next we see that
&nbsp;the
parameter <span style="font-weight: bold;">eval.problem</span>
is set to&nbsp;<small style="font-weight: bold;"><code>ec.app.gep.test1.test1</code></small>.
This is the name of the class that contains the code we need to supply
for our problem. We'll look at this in more detail below.&nbsp;</p>


<br>


<p class="MsoNormal"><span style="" lang="EN">The
next 2 parameters
identify the maximum number of generations
(in
this case 100) that we should run when trying to find a solution to the
problem and whether we should quit when we find a 'suitable' solution.
In this case we say that we should quit when the solution is found,
rather than continuing until 100 generations have been run. The
parameter pop.subpop.0.size tells how many instances of possible models
(or chromosomes or individuals in gep terminology) we should try in
each generation. In this example we use 50. &nbsp;At this time a
gep population consists of only 1 subpopulation so we will always use
pop.subpop.0 to refer to the population.</span></p>


<br>


<p class="MsoNormal"><span style="" lang="EN">The
following set of
parameters that start with gep.species
identify
various things that are very specific to gep problems. Each individual
in the population is a chromosome that can be composed of 1 or more
genes (there is an expectation that you've taken the time to read
external documents that describe the gep approach and that you will be
familiar with the concepts at this point; this documentation will refer
to these concepts without great explanations). Each gene is identified
by it's 'head' size and if there are multiple genes one needs to
specify the operator that will link the gene expressions together. Here
we use chromosomes with 2 genes, each with a head size of 5 and linked by
addition. <br>


<br>


</span></p>


<p class="MsoNormal">There are 4 types of
problems that
can be handled by the gep approach (at this time). In this case we are
doing a function finding problem. Genes can be composed of various
symbols that represent the functions and terminals (independent variables) that can be used.
There can also be constants but more on that later. We need to identify
these symbols so that the system can build appropriate genes. The
functions are identified by telling how many there are (functionsize)
and what they are (function.0, function.1, etc.). In this problem we
have decided to allow the genes to use the 4 functions: addition, subtraction,
multiplication and addition. There are a very large number of supported
functions. These can be found in the ec/gep/symbols directory. It is
quite simple to add more functions as needed. Just follow the example
of a similar type of function and create a new class. The terminal or
independent variable
symbols can also be defined in the parameter file but for this example
we have a training data file that contains the terminal symbols in the 1st
row of the file. So we specify that
gep.species.symbolset.terminalfilename is&nbsp;<small style="font-weight: bold;"><code>ec/app/gep/test1/test1.txt</code></small>. As
shown above this will identify the 2 terminal symbols x and y (as well as the dependent variable symbol z).&nbsp;</p>


<span style="font-family: &quot;Times New Roman&quot;;"></span>
<br>


<p class="MsoNormal"><span style="" lang="EN">The
final entries in the
parameter file describe what we want in
the
way of
output from the system. This is called the statistics output. In this
example we use the class ec.gep.GEPSimpleStatistics to
generate our output and
specify that the output will go to the file stats1.txt. Users may want
to build their own statistics classes to control the type of
information that is generated.<br>


<br>


</span></p>


<p class="MsoNormal">Finally we need to provide
a simple
program that tells the system how to evaluate the <span style="font-weight: bold;">fitness</span> of
chromosomes so
decisions can be made as the individuals are discarded or moved to the
next generation (possibly with modifications -- mutations, inversions,
and various forms of recombination and transposition). The code for the
class ec.gep.test.test1 is shown below.</p>


<br>


<small><code>import ec.*;<br>


import ec.gep.*;<br>


import ec.simple.*;<br>


<br>


/**<br>


&nbsp;*&nbsp; The problem is to find the equation x*x + y <br>


&nbsp;*&nbsp; <br>


&nbsp;*&nbsp; Data and variable names are in the data file
test1.txt<br>


&nbsp;*/<br>


public class test1 extends GEPProblem implements SimpleProblemForm <br>


{<br>


&nbsp;&nbsp;static double IDEAL_FITNESS_MINIMUM = 999.9999;<br>


&nbsp;&nbsp;&nbsp; <br>


&nbsp; public void evaluate(EvolutionState state, Individual ind,
int threadnum) <br>


&nbsp;&nbsp;{<br>


&nbsp;&nbsp;&nbsp; if (!ind.evaluated)&nbsp; // don't
bother reevaluating<br>


&nbsp;&nbsp;&nbsp;&nbsp;{<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Mean Squared
Error (MSE) fitness is normalized between 0 and 1000 (1000 * (1/(1+MSE))<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double fitness =
GEPFitnessFunction.MSEfitness((GEPIndividual)ind);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // the fitness
better be SimpleFitness!<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SimpleFitness f =
((SimpleFitness)ind.fitness);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
f.setFitness(state,(float)fitness, fitness &gt;=
IDEAL_FITNESS_MINIMUM);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ind.evaluated
= true;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;if (fitness
&gt;= IDEAL_FITNESS_MINIMUM)<br>


&nbsp;&nbsp; &nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;((GEPIndividual)ind).printIndividualForHumans(state, 1, 1);<br>


&nbsp;&nbsp;&nbsp; &nbsp;
}&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp;&nbsp;}<br>


&nbsp; }<br>


}<span style="font-family: &quot;Times New Roman&quot;;"></span></code>
</small><br>


<br>


<p class="MsoNormal">This is the basic format
that should
be used in the user program. The outer test just says that if we've
already evaluated the fitness of the individual (chromosome/model) then
don't do anything. Otherwise use one of the fitness functions to
evaluate the model (in this case we use Mean Squared Error), set the
fitness indicating whether it is an ideal solution to the problem and
then indicate that the model was evaluated. Printing the model is not
required but was done in this case. It will be captured in the
statistics file output. There are a number of possible fitness
functions to choose from (see ec.gep.GEPFitnessFunction
class) and you can easily create your own.&nbsp;</p>


<br>


<p class="MsoNormal">So now we have all of the
required pieces to
define our problem and to execute it we can use the command line or the
ECJ console. To run from a command line execute something like:<br>


<br>


<small><code>D:\ecj&gt;java -classpath
./;./start/javacsv.jar ec.Evolve
-file ec/app/gep/test1/test1.params<br>


<br>


</code></small></p>


<p class="MsoNormal">You'll
notice that there is a jar file called javacsv.jar that must be
included in the classpath. This is used to read the CSV files and can
be found at http://sourceforge.net/projects/javacsv/. Assuming all goes
well you will see the following output on the console.<br>


<br>


</p>


<p class="MsoNormal"><small><code>|
ECJ<br>


| An evolutionary computation system (version 15)<br>


| By Sean Luke<br>


| Contributors: L. Panait, G. Balan, S. Paus, Z. Skolicki,<br>


|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
J. Bassett, R. Hubley, and A. Chircop<br>


| URL: http://cs.gmu.edu/~eclab/projects/ecj/<br>


| Mail: ecj-help@cs.gmu.edu<br>


|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (better:
join ECJ-INTEREST at URL
above)<br>


| Date: April 4, 2006<br>


| Current Java: 1.5.0_10 / Java HotSpot(TM) Client VM-1.5.0_10-b03<br>


| Required Minimum Java: 1.3<br>


<br>


Threads:&nbsp; breed/1 eval/1<br>


Seed: 4357<br>


Job: 0<br>


Setting up<br>


Initializing Generation 0<br>


WARNING:<br>


Weight for GEP Function must be &gt; 0; defaulting to 1)<br>


PARAMETER: pop.subpop.0.species.symbolset.function.0.weight<br>


&nbsp;&nbsp;&nbsp;&nbsp; ALSO:
gep.species.symbolset.function.0.weight<br>


WARNING:<br>


Weight for GEP Function must be &gt; 0; defaulting to 1)<br>


PARAMETER: pop.subpop.0.species.symbolset.function.1.weight<br>


&nbsp;&nbsp;&nbsp;&nbsp; ALSO:
gep.species.symbolset.function.1.weight<br>


WARNING:<br>


Weight for GEP Function must be &gt; 0; defaulting to 1)<br>


PARAMETER: pop.subpop.0.species.symbolset.function.2.weight<br>


&nbsp;&nbsp;&nbsp;&nbsp; ALSO:
gep.species.symbolset.function.2.weight<br>


WARNING:<br>


Weight for GEP Function must be &gt; 0; defaulting to 1)<br>


PARAMETER: pop.subpop.0.species.symbolset.function.3.weight<br>


&nbsp;&nbsp;&nbsp;&nbsp; ALSO:
gep.species.symbolset.function.3.weight<br>


Generation 1<br>


</code></small></p>


<p class="MsoNormal"><small><code>Evaluated:
T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


*.x.x.y.y.x.x.y.x.x.x<br>


Gene 1<br>


y./.x.+.+.x.x.x.x.x.x<br>


<br>


(x*x) + y<br>


<br>


Found Ideal Individual</code></small><br>


<br>


The warnings about weight for the functions can be ignored. There is an
option to identify weights for the functions so that the ones with
higher weights are selected more often when building and evolving
genes. The default of 1 was used by not specifying the weights. In the
code we chose to display&nbsp;the best individual when it was found
and
thus the output showing the details for the chromosome with an ideal
fitness of 1000. It identifies the linking function used
(+), the contents of the 2 genes (in Karva format ... see the gep
documentation in papers by Ferreira, etc.) and the expression of the
chromosome in a mathematical formula:<br>


<br>


&nbsp;&nbsp;&nbsp; (x*x) + y<br>


<br>


This is clearly the solution we were looking for. You will also find
the statistics for the run in the file test1.stat. This should contain
the following information:</p>


<br>


<span style="font-family: &quot;Times New Roman&quot;;"><small><code>Seed(s)
used in
this job: 4357<br>


Problem Type: functionfinding<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 274.6781<br>


Linking function: +<br>


Gene 0<br>


-.x.-.y.y.y.y.x.y.y.y<br>


Gene 1<br>


+.x.y.y.-.x.y.y.y.y.x<br>


<br>


(x-(y-y)) + (x+y)<br>


<br>


Generation: 1<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 1000.0&lt;small&gt;&lt;code&gt;<br>


Linking function: +<br>


Gene 0<br>


*.x.x.y.y.x.x.y.x.x.x<br>


Gene 1<br>


y./.x.+.+.x.x.x.x.x.x<br>


<br>


(x*x) + y<br>


<br>


Best Individual of Run:<br>


Found at Generation: 1<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


*.x.x.y.y.x.x.y.x.x.x<br>


Gene 1<br>


y./.x.+.+.x.x.x.x.x.x<br>


<br>


(x*x) + y<br>


<br>


Size of program: 4<br>


Variables used(count): x(2), y(1)<br>


<br>


***** TRAINING data results *****<br>


Statistics: <br>


MSE:&nbsp; 0.0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; RAE:&nbsp;
0.0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
RSE:&nbsp; 0.0<br>


RMSE: 0.0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
MAE:&nbsp;
0.0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; RRSE:
0.0<br>


<br>


Observed&nbsp;&nbsp;&nbsp; Computed<br>


1.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.25<br>


3.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3.0<br>


8.0&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 8.0<br>


21.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
21.0</code></small><br>


<br>


<p class="MsoNormal"><span style="" lang="EN">The
output shows the best
individual found in each generation.
There
were only 2 generations needed to find a solution to this problem since
it was a simple one. Notice that in the first generation (generation
0), the best solution found was (x-(y-y) + (x+y). It had a fitness
value of 274.6781, well below the perfect value of 1000 that we get
with the best solution of generation 1. The statistics also
provide some other information. The size of the best solution found
during the run was 4. This means that there were 4 symbols used in the
expression (excluding the linking function). So we had 2 x terminal
symbols, 1 y terminal symbol and the * function symbol in the solution.
We also display some statistical values including mean squared error
(MSE), root mean squared error (RMSE), etc. Finally we display the
values expected or observed (from our training data) and the values
produced by the best model in the run, in this case a perfect model.</span></p>


<br>


<p class="MsoNormal"><span style="" lang="EN">So,
that's all there is
to it. Let's look at 2 more simple
problems,
test2 and test3, to see some minor variations in the process. First the
test2 example is solving a problem that should result in a model
with the expression x^4 + x^3 + x^2 + x. It has a single independent
variable, x. And in this example, instead of getting the terminal
symbols and data from a file we define the terminal symbols in the
param file, test2.param,&nbsp;and define the data in the program
file, test2.java. The relevant part of the param file is:</span></p>


<br>


<small><code>gep.species.symbolset.terminalsize = 1<br>


gep.species.symbolset.terminal.0 = x<br>


gep.species.symbolset.functionsize = 4<br>


gep.species.symbolset.function.0 = Add<br>


gep.species.symbolset.function.0.weight = 1<br>


gep.species.symbolset.function.1 = Sub<br>


gep.species.symbolset.function.1.weight = 1<br>


gep.species.symbolset.function.2 = Mul<br>


gep.species.symbolset.function.2.weight = 1<br>


gep.species.symbolset.function.3 = Div<br>


gep.species.symbolset.function.3.weight = 1</code></small><br>


<br>


<p class="MsoNormal"><span style="" lang="EN">Here
we've identified that there is 1 terminal symbol, x.
We've
also
explicitly specified that the weight for each function should be 1.
Specifying the data in the program is a bit more complex but not much.</span></p>


<br>


<small><code>package ec.gep.test;<br>


import ec.*;<br>


import ec.gep.*;<br>


import ec.simple.*;<br>


<br>


public class test2 extends GEPProblem implements SimpleProblemForm <br>


{<br>


&nbsp;&nbsp;&nbsp; public static final double
IDEAL_FITNESS_MINIMUM =
0.9999999999;<br>


<br>


&nbsp;&nbsp;&nbsp; public double xvalues[] = { 9.500366,
-6.130432,
3.252685, 7.88797, 9.090484,<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; 1.485199,
-3.950531, 10.003326, -0.607453,
5.469299};&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; public double zvalues[] = {
9103.54918799079,
1213.47815867463, 160.18146840485, <br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
4432.23529247904, 7671.79392962917, 11.8327154232663, 193.570365560718,
<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
11124.3786278048, -0.326443121119579, 1093.78835980998};&nbsp; //
x^4 +
x^3 + x^2 + x<br>


&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; public double[] getDataValues( String
label )<br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(label.equals("x"))<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return
(xvalues);<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else if
(label.equals("dependentVariable")) // always called 'dependentVariable'<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return
(zvalues);<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; else<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return
null;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; }<br>


<br>


&nbsp;&nbsp;&nbsp; public void evaluate(EvolutionState
state,
Individual ind, int threadnum) <br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (!ind.evaluated)&nbsp; //
don't bother reevaluating<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
Mean Squared Error (MSE) fitness is normalized between 0 and 1000 (1000
* (1/(1+MSE))<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double fitness = GEPFitnessFunction.MSEfitness((GEPIndividual)ind);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
//
the fitness better be SimpleFitness!<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SimpleFitness f = ((SimpleFitness)ind.fitness);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
f.setFitness(state,(float)fitness, fitness &gt;=
IDEAL_FITNESS_MINIMUM);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
ind.evaluated = true;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; if
(fitness &gt;=
IDEAL_FITNESS_MINIMUM)<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
((GEPIndividual)ind).printIndividualForHumans(state, 1, 1);<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>


&nbsp;&nbsp;&nbsp; }<br>


}</code></small><br>


<br>


<p class="MsoNormal"><span style="" lang="EN">The
main difference here is that we have to provide a method
getDataValues to supply the data values for the terminal symbols
identified in the param file. In this case that is the x value. The ECJ
system will call this function during initialization to get the values,
passing the symbol "x" as an argument. The user program must
provide a double[] result. In the previous example the data was in a
file and the first row had the symbols for the independent variable and
the dependent variable. In the parameter file we don't specify the name
of the dependent variable so the system will ask for the dependent
variable values using the label "dependentVariable". It is probably
most common to use a file to hold the training data. However, if the
training data is to be provided by performing a calculation (via a
simulation or some other means for example), then using the user
program to provide the data makes sense&nbsp;&nbsp;For test2
the
statistics
file will look like:</span></p>


<br>


<small><code>Seed(s) used in this job: 4357<br>


Problem Type: functionfinding<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 0.004819467<br>


Linking function: +<br>


Gene 0<br>


-.-.-.x.*.*.-.x.x.x.x.x.x.x.x.x.x<br>


Gene 1<br>


*.+.-.x./.x././.x.x.x.x.x.x.x.x.x<br>


Gene 2<br>


*.+.+.x.*.*.x.x.x.x.x.x.x.x.x.x.x<br>


<br>


((x-(x*x))-((x*x)-(x-x))) + ((x+((x/x)/x))*(x-(x/x))) +
((x+(x*x))*((x*x)+x))<br>


<br>


Generation: 1<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 410.7618<br>


Linking function: +<br>


Gene 0<br>


-.-.*.x.*.*.-.x.x.x.x.x.x.x.x.x.x<br>


Gene 1<br>


*.+.-.x./.x././.x.x.x.x.x.x.x.x.x<br>


Gene 2<br>


*.+.+.x.*.*./.x.x.x.x.x.x.x.x.x.x<br>


<br>


((x-(x*x))-((x*x)*(x-x))) + ((x+((x/x)/x))*(x-(x/x))) +
((x+(x*x))*((x*x)+(x/x)))<br>


<br>


Generation: 6<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 500.0<br>


Linking function: +<br>


Gene 0<br>


-.-.*.x.x.x.x.x.x.x.x.x.x.x.x.x.x<br>


Gene 1<br>


*.+./.x./.x././.x.x.x.x.x.x.x.x.x<br>


Gene 2<br>


*.+.+.x.*.*./.x.x.x.x.x.x.x.x.x.x<br>


<br>


((x-x)-(x*x)) + ((x+((x/x)/x))*(x/(x/x))) + ((x+(x*x))*((x*x)+(x/x)))<br>


<br>


Generation: 14<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


-.-.*.x.x.x.x.x.x.x.x.x.x.x.x.x.x<br>


Gene 1<br>


*.x.x.x.x.x.x.+.x.x.x.x.x.x.x.x.x<br>


Gene 2<br>


*.+.+.x.*.*./.x.x.x.x.x.x.x.x.x.x<br>


<br>


((x-x)-(x*x)) + (x*x) + ((x+(x*x))*((x*x)+(x/x)))<br>


<br>


Best Individual of Run:<br>


Found at Generation: 14<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


-.-.*.x.x.x.x.x.x.x.x.x.x.x.x.x.x<br>


Gene 1<br>


*.x.x.x.x.x.x.+.x.x.x.x.x.x.x.x.x<br>


Gene 2<br>


*.+.+.x.*.*./.x.x.x.x.x.x.x.x.x.x<br>


<br>


((x-x)-(x*x)) + (x*x) + ((x+(x*x))*((x*x)+(x/x)))<br>


<br>


Size of program: 23<br>


Variables used(count): x(13)<br>


<br>


***** TRAINING data results *****<br>


Statistics: <br>


MSE:&nbsp; 7.182716450022835E-24&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
RAE:&nbsp; 4.832470396077297E-16&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
RSE:&nbsp; 4.344516272977063E-31<br>


RMSE: 2.680059038533076E-12&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
MAE:&nbsp; 1.7715995337397316E-12&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
RRSE: 6.591294465411982E-16<br>


<br>


Observed&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; Computed<br>


9103.54918799079&nbsp;&nbsp;&nbsp; 9103.549187990786<br>


1213.47815867463&nbsp;&nbsp;&nbsp; 1213.4781586746294<br>


160.18146840485&nbsp;&nbsp;&nbsp;
&nbsp;160.18146840484988<br>


4432.23529247904&nbsp;&nbsp;&nbsp; 4432.235292479036<br>


7671.79392962917&nbsp;&nbsp;&nbsp; 7671.793929629167<br>


11.8327154232663&nbsp;&nbsp;&nbsp; 11.832715423266338<br>


193.570365560718&nbsp;&nbsp;&nbsp; 193.57036556071805<br>


11124.3786278048&nbsp;&nbsp;&nbsp; 11124.378627804794<br>


-0.326443121119579&nbsp;&nbsp;-0.3264431211195794<br>


1093.78835980998&nbsp;&nbsp;&nbsp; 1093.7883598099795</code></small><br>


<br>


<p class="MsoNormal"><span style="" lang="EN">In
this case it took 14 generations to solve the problem
with an
ideal
(fitness = 1000) solution. The solution could use some simplification
so that we see the first term is -x*x, the second is x*x
&nbsp;(which
cancel each other) and the third is (x+x*x)(x+1) or x^4+x^3+x^2+x, the
desired solution. The errors in the statistics are not exactly zero but
are quite small. This is due to loss of precision as the complex (not
simplified) expression is evaluated. It also demonstrates why we use
double and not float for all calculations. One final thing to note is
that we don't print the best result after each generation. We only
printed the results when there was an improvement in the fitness of the
best of a generation (at generations 1, 6 and 14). This can be
controlled by a parameter for the statistics. You can print the results
for every generation, only when the fitness improves (as we did here by
default) or only the final generation of the run (see the gep.params
files for details). <br>


<br>


Test3 is just test1 again, but this time we do not have to supply a
Java
program at all, we'll use the default one. The test3.param file has the
following changes:</span></p>


<br>


<small><code># Problem<br>


#===============================<br>


eval.problem = ec.gep.GEPDefaultUserProg<br>


eval.problem.fitness-function = RH<br>


eval.problem.fitness-function-arg0 = 2.0</code><br>


<br>


</small>
<p class="MsoNormal"><span style="" lang="EN">Instead
of specifying some user program like
ec.gep.test.test3 we use
ec.gep.GEPDefaultUserProg. But because we do this we need to identify
which fitness function to use. There are more than 25 fitness functions
provided and most require a single argument, the individual being
evaluated. Some require one or 2 extra numeric arguments. In the case
of test3 we've used the Relative Hits (RH) fitness function. It
requires one numeric argument, the precision. It is not necessarily the
best choice for this problem but does illustrate the use of the
parameters to specify the fitness function and an argument. The RH
function counts the number of hits (matches) between the expected
results in the training set and the computed results. A comparison is
considered to be a hit if the percentage difference between the
expected and computed values &nbsp;is less than the precision
specified,
in this case 2%. So the test is:</span></p>


<small><br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;<code>&nbsp;100*(abs(expected-computed)/expected)
&lt; precision</code><br>


<br>


</small>
<p class="MsoNormal"><span style="" lang="EN">The
maximum number of hits possible is the number of sets of
training
data. The GEPDefaultUserProg uses the RH function to determine fitness.
Check out the GEPFitnessFunction class to see the selection of
functions available and to add your own if so inclined. So for test3 we
only had to create a parameter file and a testing data file. The
results of the run should look something like:</span></p>


<small><br>


<code>Seed(s) used in this job: 4357<br>


Problem Type: functionfinding<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 3.0<br>


Linking function: +<br>


Gene 0<br>


*.-.-.+.y.y.x.x.y.x.x<br>


Gene 1<br>


-.y.-.y.y.y.y.y.x.y.x<br>


<br>


(((x+y)-y)*(y-x)) + (y-(y-y))<br>


<br>


Generation: 1<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 4.0<br>


Linking function: +<br>


Gene 0<br>


*.x.x.y.y.x.x.y.x.x.x<br>


Gene 1<br>


y./.x.+.+.x.x.x.x.x.x<br>


<br>


(x*x) + y<br>


<br>


Best Individual of Run:<br>


Found at Generation: 1<br>


Evaluated: T<br>


Fitness: 4.0<br>


Linking function: +<br>


Gene 0<br>


*.x.x.y.y.x.x.y.x.x.x<br>


Gene 1<br>


y./.x.+.+.x.x.x.x.x.x<br>


<br>


(x*x) + y<br>


<br>


Size of program: 4<br>


Variables used(count): x(2), y(1)<br>


<br>


***** TRAINING data results *****<br>


Statistics: <br>


MSE:&nbsp; 0.0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; RAE:&nbsp;
0.0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
RSE:&nbsp; 0.0<br>


RMSE: 0.0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
MAE:&nbsp;
0.0&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; RRSE:
0.0<br>


<br>


Observed&nbsp;&nbsp;&nbsp; Computed<br>


1.25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.25<br>


3.0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 3.0<br>


8.0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp; 8.0<br>


21.0&nbsp;&nbsp; &nbsp; &nbsp;&nbsp; 21.0</code></small>
<br>


<br>


<p class="MsoNormal"><span style="" lang="EN">As
you can see the final result is the same, we get the
x*x+y
equation
that the data supports. The maximum fitness value in this case was 4,
since there were only 4 training sets of data. <br>


<br>


This concludes the introduction to using the ECJ GEP extension. The
next section identifies an number of other examples that have been
implemented, showing more complex examples from the four types of
problems: function finding, logical, classification and time series.
We'll explain some of the particular parameters and considerations for
these types of problems as we briefly describe the examples.</span></p>


<br>


<br>


</span>
<h1><a name="Some_examples"><span class="Section1 MsoNormal">Some
Other
Examples<br>


</span></a></h1>


<h1><a name="Function_Finding_Examples"></a>Function
Finding
Examples</h1>


<p class="MsoNormal"><br>


These examples are similar to the test1, test2 and test3 examples we
explored in the previous section. We'll just describe them very briefly
and point out any interesting new things that are introduced.<br>


<br>


<span style="font-weight: bold;">1. Acot Example</span>
- this is an
attempt to discover the ArcCotangent function using a set of
&nbsp;100
training cases. There is only 1 gene, 30 chromosomes (individuals) in
the population and the RRSE (Root Relative Squared Error)
&nbsp;fitness
function is used. There is one independent variable, d0, specified in
the Acot.param file. There are 17 functions used (+, -, *, /, Sqrt,
Exp, Floor,&nbsp;Ceiling, Abs, Neg, Sin, Cos, Tan, Asin, Acos,
Atan,
and Ln). The add, subtract, multiply and divide functions have a weight
of 3 and the others a weight of 1. These are just variations of things
we've seen before. The new thing is that in this example we allow the
genes to encode not only functions and terminals but also constants.
This is described in Ferreira's book and the GeneXproSoft software. But
in order to use constants you do need to supply some extra information.<br>


<br>


<small><code>gep.species.use-constants&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= true<br>


gep.species.numconstantspergene&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 2<br>


gep.species.integer-constants&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= false<br>


gep.species.constants-lowerlimit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= -10<br>


gep.species.constants-upperlimit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 10<br>


gep.species.rnc-mutation-prob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0.01<br>


gep.species.dc-mutation-prob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0.044<br>


gep.species.dc-inversion-prob&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0.1<br>


gep.species.dc-istransposition-prob&nbsp;&nbsp; = 0.1</code></small><br>


<br>


First we identify that we are going to use constants and that there
will be 2 constants allocated per gene. we are using floating point
constants since integer-constants is set to false. The values of the
constants are allowed to range between -10.0 and +10.0. The other
parameters relate to how constants evolve from generation to
generation. this again is covered in Ferreira's documentation. But
these values are the ones she suggests as defaults that work well for
most problems.<br>


<br>


After running the example we get the output in the Acot.stat file.<br>


<br>


<small><code>Seed(s) used in this job: 4357<br>


Problem Type: functionfinding<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 499.85913<br>


Linking function: +<br>


Gene 0<br>


ceil.tan.C1.tan.d0.C0.tan.acos.d0.d0.d0.C1.C1.C1.d0.C1.C1<br>


C0: -8.147180372252937<br>


C1: 5.652730175877368<br>


<br>


ceiling(tan(5.652730175877368))<br>


<br>


Generation: 10<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 503.19714<br>


Linking function: +<br>


Gene 0<br>


/.cos.C1.tan.tan.sin.d0.d0.d0.C1.C0.C1.C0.C0.d0.C0.d0<br>


C0: -1.9238205968468058<br>


C1: 5.576872726631521<br>


<br>


(cos(tan(tan(sin(d0))))/5.576872726631521)<br>


<br>


Generation: 14<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 614.31683<br>


Linking function: +<br>


Gene 0<br>


/.cos.d0.floor.C1.d0.floor.d0.d0.C1.C0.C1.C1.C0.d0.C1.d0<br>


C0: -8.147180372252937<br>


C1: 5.652730175877368<br>


<br>


(cos(floor(5.652730175877368))/d0)<br>


<br>


Generation: 21<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 873.75574<br>


Linking function: +<br>


Gene 0<br>


sin././.cos./.neg.*.floor.d0.C1.C0.C0.C1.C1.d0.d0.d0<br>


C0: -8.147180372252937<br>


C1: 5.652730175877368<br>


<br>


sin((((floor(5.652730175877368)/d0)/(-5.652730175877368))/cos(((-8.147180372252937)*(-8.147180372252937)))))<br>


<br>


Generation: 366<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


atan././.d0.d0.d0./.C1.d0.d0.C1.C0.C0.d0.C0.C1.C1<br>


C0: -8.147180372252937<br>


C1: -0.24815065988408236<br>


<br>


atan(((d0/d0)/d0))<br>


<br>


Best Individual of Run:<br>


Found at Generation: 366<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


atan././.d0.d0.d0./.C1.d0.d0.C1.C0.C0.d0.C0.C1.C1<br>


C0: -8.147180372252937<br>


C1: -0.24815065988408236<br>


<br>


<span style="font-weight: bold;">atan(((d0/d0)/d0))</span><br>


<br>


Size of program: 6<br>


Variables used(count): d0(3)<br>


<br>


***** TRAINING data results *****<br>


Statistics: <br>


MSE:&nbsp; 6.5223928682607005E-31&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;RAE:&nbsp;
1.4189629717074661E-15&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; RSE:&nbsp; 5.2194614261805544E-30<br>


RMSE: 8.076133275436148E-16&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
MAE:&nbsp; 3.738676035425215E-16&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
RRSE: 2.284614065040429E-15<br>


<br>


Observed&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Computed<br>


-0.204002518946359&nbsp;&nbsp;&nbsp; -0.2040025189463591<br>


-0.339365885046348&nbsp;&nbsp;&nbsp; -0.3393658850463476<br>


-0.387522092113786&nbsp;&nbsp;&nbsp; -0.3875220921137857<br>


-0.23995309898349&nbsp; &nbsp;&nbsp; -0.23995309898349046<br>


0.515703851271719&nbsp;&nbsp; &nbsp;&nbsp;
0.5157038512717189<br>


0.310364838997948&nbsp;&nbsp; &nbsp;&nbsp;
0.31036483899794765<br>


&nbsp;&nbsp;&nbsp; ...<br>


0.146141817137733&nbsp;&nbsp; &nbsp;&nbsp;
0.14614181713773297<br>


-0.124890152806863&nbsp;&nbsp;&nbsp; -0.1248901528068634<br>


-0.182368282843355&nbsp;&nbsp;&nbsp; -0.18236828284335482<br>


0.160813070832659&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.1608130708326594<br>


0.139880646214395&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.13988064621439456<br>


</code></small><br>


It took 366 generations in this case (with the seed provided) and found
the expression atan(((d0/do)/do)) which is equivalent to atan(1/d0),
the definition of acot(d0). There were improvements in the best fitness
value at generations 10, 14, 21, and 366. So there was a lot of
exploration of models through evolution to improve between generation
21 and 366.<br>


<br>


<span style="font-weight: bold;">2. Data mining example</span>
- This
is an interesting variation of the test2 problem described above. This
high-dimensional toy problem illustrates the use of a great deal of
extraneous&nbsp;information being filtered during evolution. In
this
example 15 out of 16 independent&nbsp;variables are meaningless. As
in
test2 the target function is the quadric polynomial f(x) =
x^4+x^3+x^2+x. The data contained 161 sets with 15 independent variable
values plus the dependent variable values. As we can see from the
(partial) output shown below, it takes 1596 generations (with the given
seed as the starting point) to get to the best solution.<br>


<br>


<small><code>Seed(s) used in this job: 4357<br>


Problem Type: functionfinding<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 459.41364<br>


Linking function: +<br>


Gene 0<br>


+./.-.*.*./.-.*.d0.d2.d15.d13.d4.d12.d10.d6.d6<br>


Gene 1<br>


+.d6.*.-.+.d5./.*.d3.d12.d3.d13.d0.d8.d14.d12.d7<br>


Gene 2<br>


-.*.-./.-.d8.*./.d0.d13.d8.d7.d12.d0.d11.d4.d5<br>


<br>


((((d6*d6)*d0)/(d2*d15))+((d13/d4)-(d12-d10))) +
(d6+((d5-(d12/d3))*((d13*d0)+d3))) +
((((d0/d11)/d0)*(d13-d8))-(d8-(d7*d12)))<br>


<br>


Generation: 3<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 461.31992<br>


Linking function: +<br>


Gene 0<br>


+.-.-.*.*./.-.*.d0.d2.d15.d13.d4.d12.d10.d6.d6<br>


Gene 1<br>


+.d6.*.-.+.d5./.*.d3.d12.d3.d13.d0.d8.d14.d12.d7<br>


Gene 2<br>


-.*.-./.-.d8.*./.d0.d13.d8.d7.d12.d0.d11.d4.d5<br>


<br>


((((d6*d6)*d0)-(d2*d15))+((d13/d4)-(d12-d10))) +
(d6+((d5-(d12/d3))*((d13*d0)+d3))) +
((((d0/d11)/d0)*(d13-d8))-(d8-(d7*d12)))<br>


<br>


&nbsp;&nbsp;&nbsp; ...<br>


<br>


Generation: 1347<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 998.6959<br>


Linking function: +<br>


Gene 0<br>


+.*.d6.*.d0.d0.d0.-.d5.d12.d7.d5.d8.d4.d10.d5.d4<br>


Gene 1<br>


-.*.d1.d0.+.*.d0.*.d0.d0.d0.d10.d11.d8.d10.d5.d10<br>


Gene 2<br>


+.-.d0.d1.+.d6.d1.d1.d3.d6.d0.d8.d5.d8.d0.d2.d14<br>


<br>


(((d0*d0)*d0)+d6) + ((d0*(((d0*d0)*d0)+d0))-d1) + ((d1-(d6+d1))+d0)<br>


<br>


Generation: 1596<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


+.-.d0.d1.d6.-.d1.*.d0.d12.d2.d9.d5.d6.d9.d12.d12<br>


Gene 1<br>


-.*.d1.+.d0.*.d0.*.d0.d0.d0.d7.d5.d15.d9.d12.d1<br>


Gene 2<br>


+.*.d6.*.*./.d0.d0.d0.d0.d0.d10.d5.d8.d5.d8.d7<br>


<br>


((d1-d6)+d0) + (((((d0*d0)*d0)+d0)*d0)-d1) + ((((d0/d0)*d0)*(d0*d0))+d6)<br>


<br>


Best Individual of Run:<br>


Found at Generation: 1596<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


+.-.d0.d1.d6.-.d1.*.d0.d12.d2.d9.d5.d6.d9.d12.d12<br>


Gene 1<br>


-.*.d1.+.d0.*.d0.*.d0.d0.d0.d7.d5.d15.d9.d12.d1<br>


Gene 2<br>


+.*.d6.*.*./.d0.d0.d0.d0.d0.d10.d5.d8.d5.d8.d7<br>


<br>


(<span style="font-weight: bold;">(d1-d6)+d0) +
(((((d0*d0)*d0)+d0)*d0)-d1) + ((((d0/d0)*d0)*(d0*d0))+d6)</span><br>


<br>


Size of program: 27<br>


Variables used(count): d0(11), d1(2), d6(2)<br>


<br>


***** TRAINING data results *****<br>


Statistics: <br>


MSE:&nbsp; 7.99571803020474E-23&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
RAE:&nbsp; 1.0804622056054273E-15&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;
RSE:&nbsp; 4.6576363300204115E-30<br>


RMSE: 8.941877895724556E-12&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; MAE:&nbsp;
3.3320664912135643E-12&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; RRSE:
2.1581557705643983E-15<br>


<br>


Observed&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; Computed<br>


1418.74707069507&nbsp;&nbsp;&nbsp; 1418.7470706950726<br>


75.3238688522697&nbsp;&nbsp;&nbsp; 75.3238688522697<br>


11019.4252335609&nbsp;&nbsp;&nbsp; 11019.425233560933<br>


1526.50067316805&nbsp;&nbsp;&nbsp; 1526.500673168051<br>


11309.522753932&nbsp;&nbsp;&nbsp;
&nbsp;11309.522753931999<br>


6755.18648304066&nbsp;&nbsp;&nbsp; 6755.186483040658<br>


&nbsp;&nbsp;&nbsp; ...<br>


537.603328324592&nbsp;&nbsp;&nbsp; 537.603328324592<br>


533.236668818159&nbsp;&nbsp;&nbsp; 533.2366688181589<br>


3742.26191483226&nbsp;&nbsp;&nbsp; 3742.261914832265<br>


6664.98407320731&nbsp;&nbsp;&nbsp; 6664.984073207315<br>


8312.11655791031&nbsp;&nbsp;&nbsp; 8312.116557910313</code></small><br>


<br>


You'll also notice that for this particular run the solution looks
pretty complex but it simplifies to:<br>


<br>


&nbsp;&nbsp;&nbsp;<code> <small>d1-d6+d0 +
d0^4+d0^2-d1 + d0^3+d6</small></code><br>


or<br>


&nbsp;&nbsp;&nbsp;<small><code> d0&nbsp;+
d0^4 + d0^2 + d0^3</code></small><br>


<br>


the expected solution.&nbsp;There
is a second
version of the program, dataMining2 that has the data in a CSV text
file.<br>


<br>


<span style="font-weight: bold;">3. Production example</span>
- In this
example we have real-world production data from 446 firms. The goal is
to explain the Production&nbsp;as a function of Labor, Material,
and
Capital. There is nothing new in the parameter file that we haven't
seen before. The data is provided in the user program. The only unique
thing we haven't seen before is that the program runs to completion at
3000 generations without reaching an 'ideal' or 'perfect' solution.
This is probably more like real problems with real (imperfect) data. We
only explored the solution using the functions add, subtract, multiply
and divide. Perhaps there are more complicated relations ships and
trying some trigonometric functions might help. In any case, this
attempt provided a solution with a fitness of 8878.4472. In real
investigations we might run this problem 500 or 1000 times with
different seeds for 10000 generations each to try to find a set of best
possible solutions. The best solution of the run is extracted from the
statistics output file and shown below. Note the role of constants in
the solution.<br>


<br>


<small><code>Best Individual of Run:<br>


Found at Generation: 2999<br>


Evaluated: T<br>


Fitness: 878.4472<br>


Linking function: +<br>


Gene 0<br>


/.*./.-.-./.material./.material.capital.material.C0.labour.material.material.C0.C0<br>


C0: 7.249937058678704<br>


C1: -0.5794351361736538<br>


<br>


Gene 1<br>


material.material.material./.C0.+.labour.labour.capital.capital.labour.C1.material.material.capital.capital.C1<br>


C0: 3.697751463839939<br>


C1: 2.8929911331385565<br>


<br>


Gene 2<br>


*./././.-.C1./.-.material.C0.material.C1.material.material.labour.labour.labour<br>


C0: -3.2099741094356737<br>


C1: -0.49638400660778004<br>


<br>


((((material/material)-material)*(capital-material))/((7.249937058678704/labour)/material))
+ material +
((((material-labour)/material)/((-3.2099741094356737)-material))*((-0.49638400660778004)/((-0.49638400660778004)/material)))<br>


<br>


Size of program: 31<br>


Variables used(count): labour(2), material(10), capital(1)<br>


<br>


</code></small>
</p>


<p class="MsoNormal"><span style="" lang="EN"><span style="font-weight: bold;">4.
&nbsp;Analog
Circuit Design Example</span>
- The goal is to find the transfer function expressing the yield of an
analog circuit&nbsp;in terms of three parameter tolerances. The
training set, consisting of 40 pairs&nbsp;of tolerances and their
corresponding yields, was obtained from n runs of Monte
Carlo&nbsp;simulations. The source of the problem is:
<br>


<br>


<div style="margin-left: 40px;">Zielinski,
L. and J.
Rutkowski, 2004. Design Tolerancing with Utilization of Gene<br>


Expression Programming and Genetic Algorithm. In
Proceedings of the International <br>


Conference on Signals and Electronic Systems,
Poznan,
Poland.<br>


</div>


</span></p>


<p class="MsoNormal"><br>


Again this is similar to other function finding problems we've seen.
However, this problem sets parameters to: use 10 integer constants per
gene; run to 5000 generations;&nbsp;weight add, subtract and
multiply
at 3; and to use ln, sqrt, and pow functions. Check out the files
analogCircuit.java, analogCircuit.param and analogCircuit.stat.<br>


<code>&nbsp;&nbsp;&nbsp; <br>


</code></p>


<h1><a name="Classification_Examples"></a>Classification
Examples</h1>


<p class="MsoNormal"><br>


Classification examples we haven't seen yet. Typically we'll have a set
of examples of things that belong to various classes. Each of the
examples will have a set of attributes that we hope allow us to predict
which class the examples belong to and as new (unclassified) examples
arrive we can use this knowledge to determine the class of the new
example. In the gep approach we work with one class at a time bt taking
the training examples we have and identifying the the selected class if
the example belongs to the class or does not belong to the class. In
this method, the dependent variable will have the values 0 and 1,
representing whether the example does not or does belong to the class.
By repeating for all of the classes we can construct a set of
&nbsp;equations that allows up to predict whether a new example
belongs
to each class or not. The model (equation) produced will need to result
in a zero or a 1. To do this we select a threshold value. If the
equations results in a value greater than this vaue then return a 1 (in
the class) and if below the threshold return a 0 (not in the class).
Let's look at a few examples and see how to set things up in the
parameter files.&nbsp;<br>


<br>


<span style="font-weight: bold;">1. Iris Virginica Example</span>
- In
this problem the goal is to classify three different types of irises
based&nbsp;on four measurements: sepal length, sepal width, petal
length, and petal width.&nbsp;The original iris dataset contains
fifty
examples each of three types of &nbsp;iris: Iris setosa, Iris
versicolor, and Iris virginica. Here the sub-problem
Virginica&nbsp;versus Not Virginica is analyzed, where 100 randomly
chosen samples are used for training&nbsp;and the remaining 50 for
testing. The new things in the parameter file (IrisVirginica.param) are
shown below.<br>


<br>


<small><code># Problem type must be one of:
functionfinding,
classification, timeseries, logical<br>


# Set default to be 'unknown' so user is forced to specify in the
problem params file <br>


gep.species.problemtype = classification<br>


<br>


# if the problem is a classification type problem a threshold value
(used<br>


# to convert real values to 0 or 1 during fitness calculations) must be
<br>


# specified (do not specify this unless it IS a classification type
problem).<br>


gep.species.classification-threshold&nbsp; = 0.5<br>


<br>


gep.species.symbolset.terminalfilename = ec/app/gep/</code></small><small><code>IrisVirginica</code></small><small><code>/IrisVirginica.txt<br>


gep.species.symbolset.testingdatafilename =
ec/app/gep/</code></small><small><code>IrisVirginica</code></small><small><code>/IrisVirginicaTest.txt<br>


</code></small><br>


</p>


<p class="MsoNormal">We see that the problem type is set
to <span style="font-weight: bold;">classification</span>.
With classification problems we expect to see a classification
threshold specified, In this case the value is set to 0.5. The data is
in CSV files. The training data set is in IrisVirginica.txt. There are
100 sets of data in the file along with the fisrt record that holds the
names of the terminals (variables) as d0, d1, d2, and D.V. We see also
that there is a testing data set file specified as
IrisVirginicaTest.txt. This file holds the 50 testing sets of data and <span style="font-weight: bold;">does not</span>
have the names of the varibles in the first row! When the best model is
determied from the run, the gep system will automatically access the
test data and compare the results of using the model with this data
against the expected values. This will help in the assesment of the
quality of the model that was chosen. Let's look at the output from a
run (IrisVirginica.stat). We set the problem to run for 5000
generations.</p>


<br>


<small><code>Seed(s) used in this job: -1368642168<br>


Problem Type: classification<br>


Classification rounding threshold: 0.5<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 801.24774<br>


Linking function: +<br>


Gene 0<br>


*./.+.+.*./.-.d2.d3.d0.d1.d3.d3.d3.d1.d3.d3<br>


C0: 4.19396659531718<br>


C1: 4.2865486803954775<br>


<br>


Gene 1<br>


+./.d3.-.+./.d2.d1.d1.d3.d0.C1.d2.d1.C1.d2.d1<br>


C0: 2.4700381059064878<br>


C1: 8.534256473201435<br>


<br>


Gene 2<br>


/.d1.*.-.*.d1.d2.d1.d0.d2.d2.d0.C1.d1.d0.C0.C0<br>


C0: 4.031580228177383<br>


C1: 1.4026131599950642<br>


<br>


(((d2+d3)/(d0*d1))*((d3/d3)+(d3-d1))) + ((((d3/d0)-d2)/(d1+d1))+d3) +
(d1/((d1-d2)*(d1*d0)))<br>


<br>


&nbsp;&nbsp;&nbsp; ...<br>


<br>


Generation: 9<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 969.69696<br>


Linking function: +<br>


Gene 0<br>


-.d3./.+.d2.*./.d0.d1.d1.d1.d1.d3.d1.d2.d2.d2<br>


C0: 0.2103929964396789<br>


C1: 4.2865486803954775<br>


<br>


Gene 1<br>


-.*./.-.d3.d3.C1.d2.d1.d3.d2.C1.d0.d2.d3.d2.d1<br>


C0: 2.4700381059064878<br>


C1: 8.534256473201435<br>


<br>


Gene 2<br>


/.d1.*.-.*.d1.d2.d1.C1.d1.d3.d3.C0.d3.d0.C1.C0<br>


C0: 4.031580228177383<br>


C1: 1.4026131599950642<br>


<br>


(d3-(((d0*d1)+(d1/d1))/d2)) + (((d2-d1)*d3)-(d3/8.534256473201435)) +
(d1/((d1-d2)*(d1*1.4026131599950642)))<br>


<br>


Generation: 421<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 984.8485<br>


Linking function: +<br>


Gene 0<br>


-.-././.d3.d0.d3.*.d1.d1.d2.C0.d2.d3.C0.d2.d2<br>


C0: 9.274259134965515<br>


C1: 4.873682980602775<br>


<br>


Gene 1<br>


-.d3./.+.d2.*.C1.d0.d1.d2.d2.d2.d2.C0.d2.C1.d0<br>


C0: 3.9855714658085004<br>


C1: 8.534256473201435<br>


<br>


Gene 2<br>


-.d2././.d2.d2.C1.-.C0.C0.d1.d0.d0.d0.C1.d3.d0<br>


C0: 1.8621216876649604<br>


C1: 6.2762163390852646<br>


<br>


((((d1*d2)/d1)-d3)-(d0/d3)) + (d3-(((d0*d1)+8.534256473201435)/d2)) +
(d2-((d2/6.2762163390852646)/d2))<br>


<br>


Best Individual of Run:<br>


Found at Generation: 421<br>


Evaluated: T<br>


Fitness: 984.8485<br>


Linking function: +<br>


Gene 0<br>


-.-././.d3.d0.d3.*.d1.d1.d2.C0.d2.d3.C0.d2.d2<br>


C0: 9.274259134965515<br>


C1: 4.873682980602775<br>


<br>


Gene 1<br>


-.d3./.+.d2.*.C1.d0.d1.d2.d2.d2.d2.C0.d2.C1.d0<br>


C0: 3.9855714658085004<br>


C1: 8.534256473201435<br>


<br>


Gene 2<br>


-.d2././.d2.d2.C1.-.C0.C0.d1.d0.d0.d0.C1.d3.d0<br>


C0: 1.8621216876649604<br>


C1: 6.2762163390852646<br>


<br>


((((d1*d2)/d1)-d3)-(d0/d3)) + (d3-(((d0*d1)+8.534256473201435)/d2)) +
(d2-((d2/6.2762163390852646)/d2))<br>


<br>


Size of program: 27<br>


Variables used(count): d0(2), d1(3), d2(5), d3(3)<br>


<br>


***** TRAINING data results *****<br>


Confusion Matrix: <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Predicted Value<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; Yes&nbsp;&nbsp; |&nbsp; No<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes|&nbsp; 34&nbsp;&nbsp;&nbsp; |&nbsp; 0<br>


Actual Value&nbsp;&nbsp; |----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
No
|&nbsp; 1&nbsp;&nbsp; &nbsp;&nbsp;|&nbsp; 65<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


<br>


<br>


***** TEST data results *****<br>


Number of Calculation Errors: 0 out of 50 test sets<br>


Confusion Matrix: <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Predicted Value<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; Yes&nbsp;&nbsp; |&nbsp; No<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes|&nbsp; 16&nbsp;&nbsp;&nbsp; |&nbsp; 0<br>


Actual Value&nbsp;&nbsp; |----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
No
|&nbsp; 0&nbsp;&nbsp; &nbsp; |&nbsp; 34<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


<br>


Observed&nbsp;&nbsp;&nbsp; Computed<br>


1.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.0<br>


1.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1.0<br>


0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
0.0<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</code></small><br>


<br>


<p class="MsoNormal">We see from the 'confusion matrix'
that the model produced
from
this
run predicted all but 1 data set correctly for the training data (a
false positive). And for the test data set it&nbsp; predicted all
of
the &nbsp;examples correctly.&nbsp; We can also see that the
output has
been truncated. In the stat file you'll see that all of the observed
and computed values are displayed, including the results for
the&nbsp;test data values (after the training data values). One
last
note. The line that identifies the number of calcualtion erros refers
to the number of times that the model produced an arithmetic error when
applied to the test set of data. This can happen, for example, when the
model has a division and the test values lead to a zero divisor.</p>


<br>


<br>


<p class="MsoNormal"><span style="font-weight: bold;">2.
Breast
Cancer Example</span> -
In
this example of diagnosis of breast cancer the task is to classify a
tumor as either benign (0) or malignant (1) based on nine
different&nbsp;cell analysis (clump thickness, uniformity of cell
size,
uniformity of cell shape, marginal&nbsp;adhesion, single epithelial
cell size, bare nuclei, bland chromatin, normal nucleoli, and mitoses).
Data obtained from PROBEN1 (Prechelt, L., 1994. PROBEN1 - A set of
neural network&nbsp;benchmark problems and benchmarking rules.
Technical Report 21/94, Univ. Karlsruhe, Germany).&nbsp;Both the
technical report and the data set cancer1 used here are available for
anonymous FTP&nbsp;from Neural Bench archive at Carnegie Mellon
University (machine ftp.cs.cmu.edu,
directory&nbsp;/afs/cs/project/connect/bench/contrib/prechelt) and
from
machine ftp.ira.uka.de in directory&nbsp;/pub/neuron. The file name
in
both cases is proben1.tar.gz.</p>


<br>


<p class="MsoNormal">Nothing new here except that there is
a large amount of data (training
and testing). Run the problem or check out the results in
BreastCancer.stat.</p>


<br>


<br>


<p class="MsoNormal"><span style="font-weight: bold;">3.
DNA
MicroArrays Example</span>
-
The objective of this problem is to distinguish between 2 types of
leukemia, ALL (0)&nbsp; and AML (1). There are 38 training data
sets
and 34 testing data sets. The major difference of this example is the
number of attributes. There are 7129 independent variables! One minor
change from the other examples is that we specified a tab as the
separator in the data files rather than the default comma
(gep.species.symbolset.terminalfileseparator = tab). The data sets are
available at:
&nbsp;http://sdmc.lit.org.sg/GEDatasets/Data/ALL-AML_Leukemia.zip.
Note
that these files have very long lines and many editors will have
difficulty reading or editing them. with the default seed vale an ideal
solutio is found after xxxx generations. But as you can see from the
output the model did not perform well with the test data. A good model
for the training data doesn't mean we have a solution. More runs will
be required to find solutions that can match the test and training data
well.</p>


<br>


<small><code>Best Individual of Run:<br>


Found at Generation: 2924<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: +<br>


Gene 0<br>


-.d2452.*.d4739.*.*.+.*.d4572.d4791.d1108.d4210.d670.d4458.d1985.d5621.d5374<br>


Gene 1<br>


+.d6935.*.+.+.*.+.d4555.d221.d1529.d3911.d2841.d1838.d2397.d4492.d6959.d1045<br>


Gene 2<br>


*.-.*.*.d6801.-.*.*.d11.d749.d6727.d2841.d7054.d5751.d6694.d436.d6498<br>


<br>


(d2452-(d4739*(((d4210*d670)*d4572)*(d4791+d1108)))) +
(d6935+(((d1529*d3911)+(d2841+d1838))*(d4555+d221))) +
((((d5751*d6694)*d11)-d6801)*((d749-d6727)*(d2841*d7054)))<br>


<br>


Size of program: 41<br>


Variables used(count): d11(1), d221(1), d670(1), d749(1), d1108(1),
d1529(1), d1838(1), d2452(1), d2841(2), d3911(1), d4210(1), d4555(1),
d4572(1), d4739(1), d4791(1), d5751(1), d6694(1), d6727(1), d6801(1),
d6935(1), d7054(1)<br>


<br>


***** TRAINING data results *****<br>


Confusion Matrix: <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Predicted Value<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; Yes&nbsp;&nbsp;&nbsp;|&nbsp; No<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes|&nbsp; 11&nbsp;&nbsp;&nbsp; |&nbsp; 0<br>


Actual Value&nbsp;&nbsp; |----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
No
|&nbsp; 0&nbsp;&nbsp; &nbsp; |&nbsp; 27<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


<br>


<br>


***** TEST data results *****<br>


Number of Calculation Errors: 0 out of 34 test sets<br>


Confusion Matrix: <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Predicted Value<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; Yes&nbsp;&nbsp;&nbsp;|&nbsp; No<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes|&nbsp; 4&nbsp;&nbsp; &nbsp;&nbsp;|&nbsp; 10<br>


Actual Value&nbsp;&nbsp; |----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
No
|&nbsp; 2&nbsp;&nbsp; &nbsp;&nbsp;|&nbsp; 18<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------</code></small><br>


<br>


<p class="MsoNormal">Also see the publication:<br>


<br>


&nbsp;&nbsp;&nbsp; "Molecular Classification of Cancer:
Class Discovery
and Class Prediction by <br>


&nbsp;&nbsp;&nbsp; Gene&nbsp;Expression Monitoring".
Science,
286:531-537, October 1999.
</p>


<br>


<br>


<h1><a name="Time_Series_Examples"></a>Time
Series Examples</h1>


<br>


<p class="MsoNormal">The special thing about time series
problems (as found in gep) is that the
data is a
single sequence of data. From a training sequence of time series data
we'd like to create a model that can predict new values (i.e. given a
test
sequence of time series data what would the next value in the sequence
be). To this end the sequential time series data is preprocessed to
create a set of training data sets and a set of testing data sets. To
do this the user must provide a bit of information about how the
processing should be done. The user must specify &nbsp;3 things in
the param file: <br>


<br>


<span style="font-weight: bold;">timeseries-delay</span>
- This integer value determines how to use the values in the timeseries
data. If the value is 1 then use every time series value, if it is 2
then use every other one, etc.<br>


<br>


<span style="font-weight: bold;">timeseries-embeddingdimension</span>&nbsp;-
This integr value determines the number of timeseries points to
use&nbsp;as independent variables when transforming the set of time
series data. Another&nbsp;data point is used as the dependent
variable value. So the time series 'raw' data consisting of a list of
single values is processed by splitting the data into&nbsp;groups
(rows) of size embeddingdimension+1. From the end of the time series
data&nbsp;embeddingdimension+1 values are chosen (if delay is 1 all
values are chosen, if it is 2 every other one is chosen). The last
value is the independent variable value.&nbsp;Then the next row is
selected by moving 'delay'&nbsp;values from the end and chosing
another embeddingdimension+1 values. This is repeated&nbsp;until no
more sets of size embeddingdimension+1 can be chosen.&nbsp;If this
produces&nbsp;n sets of data then <span style="font-weight: bold;">timeseries-testingpredictions</span>
of them are used for testing and (n -&nbsp;<span style="font-weight: bold;">timeseries-testingpredictions</span>)
are used for training.<br>


<br>


<span style="font-weight: bold;">timeseries-testingpredictions</span>
- an integer that specifies the number of sets of data to devote to
testing.<br>


<br>


So if we had the time series data:<br>


<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<small><code>
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21</code></small><br>


<br>


and delay was 1 and&nbsp;<span style="font-weight: bold;">timeseries-embeddingdimension</span>
was 4 then we'd process the set into&nbsp;the following 17 data
sets. If&nbsp;<span style="font-weight: bold;">timeseries-testingpredictions</span>
was 6 then the 1st 11&nbsp;would be used for training and the LAST
6 for testing.&nbsp;<br>


<br>


<small><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
iv1 iv2 iv3 iv4&nbsp; dv<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp;
4&nbsp;&nbsp; 5<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp;
5&nbsp;&nbsp; 6<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp; 4&nbsp;&nbsp; 5&nbsp;&nbsp;
6&nbsp;&nbsp; 7<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. . .<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
14&nbsp; 15&nbsp; 16&nbsp; 17&nbsp; 18<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
15&nbsp; 16&nbsp; 17&nbsp; 18&nbsp; 19<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
16&nbsp; 17&nbsp; 18&nbsp; 19&nbsp; 20<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
17&nbsp; 18&nbsp; 19&nbsp; 20&nbsp; 21<br>


<br>


</code></small></p>


<p class="MsoNormal">
If delay was 2 then 7 sets would be formed as:<br>


<br>


</p>


<small><code></code></small>
<p class="MsoNormal"><small><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
iv1 iv2 iv3 iv4&nbsp; dv<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
1&nbsp;&nbsp; 3&nbsp;&nbsp; 5&nbsp;&nbsp;
7&nbsp;&nbsp; 9<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
3&nbsp;&nbsp; 5&nbsp;&nbsp; 7&nbsp;&nbsp;
9&nbsp; 11<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
. . .<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
9&nbsp; 11&nbsp; 13&nbsp; 15&nbsp; 17<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
11&nbsp; 13&nbsp; 15&nbsp; 17&nbsp; 19<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
13&nbsp; 15&nbsp; 17&nbsp; 19&nbsp; 21</code></small><br>


<br>


&nbsp;Of course the user can provide the data already preprocessed
into the 2 data sets as we have done before, but that could require a
lot more effort. The timeseries data file must not have any information
regarding the names of the independent variables, since these are
automatically created.<br>


<br>


<span style="font-weight: bold;">1. Dow Jones Example</span>
- This example looks at the monthly closings of the Dow-Jones
industrial index, Aug. 1968 - Aug. 1981. (Source:&nbsp;Hipel and
Mcleod (1994). Time Series Modelling of Water Resources and
Environmental&nbsp;Systems, Elsevier. The original time series data
file DJ.DAT came from:<br>


<br>


&nbsp;&nbsp;&nbsp; Hyndman, R.J. (n.d.) Time Series Data
Library, http://www.robhyndman.info/TSDL/. <br>


&nbsp;&nbsp;&nbsp; Accessed on June 3, 2006.<br>


<br>


For the integral time series used in this example, each value from the
original raw timeseries was replaced by its moving average using a
smoothing period p = 10.<br>


<br>


Of interest in the example is that there are 40 functions used to build
the models and that the 3 timeseries values are set to:<br>


<br>


gep.species.timeseries-delay&nbsp;&nbsp; =&nbsp; 1<br>


gep.species.timeseries-embeddingdimension = 10<br>


gep.species.timeseries-testingpredictions = 10 <br>


<br>


Some of the statistics output:<br>


<br>


<small><code>Seed(s) used in this job: 4357<br>


Problem Type: timeseries<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 862.8322<br>


Linking function: +<br>


Gene 0<br>


gau.comp.*.v6.C1.*.v7.mul3.v6.C0.v3.v3.v6.v8.v8.v3.v5.v6.v6.v9.v6.v1.C0.v0.v4.v2.v0.v2.v9.v3.C1.v8.v9<br>


C0: -1.8928414198253574<br>


C1: -9.528899601444923<br>


<br>


Gene 1<br>


max2.X3.v9.C0.exp.-.v0.v9.v0.v8.v3.v9.v6.v2.v1.v7.v6.v6.v0.v2.v3.v7.v6.v7.v3.v3.v1.v8.v7.v3.v8.v3.v7<br>


C0: 5.353542014548175<br>


C1: -9.236307382044629<br>


<br>


Gene 2<br>


pi.v4.X5.v0.*.comp.min2.v7.v3.C1.v9.v3.v5.v1.v2.v9.v7.C0.v7.v8.v6.v5.v3.v8.v9.v1.v8.v0.v9.v2.v5.v0.v1<br>


C0: 9.111412390259325<br>


C1: 9.94532215973475<br>


<br>


exp(-pow((1-(v6*(-9.528899601444923))),2)) +
max((5.353542014548175^3),v9) + pi<br>


<br>


Generation: 2<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 866.1386<br>


Linking function: +<br>


Gene 0<br>


gau.comp.*.v7.C1.*.v7.mul3.v6.C0.v4.v3.v6.v8.v8.v3.v5.v6.v6.v9.v6.v5.C0.v0.v4.v2.v0.v2.v9.v3.C1.v8.C1<br>


C0: -1.8928414198253574<br>


C1: -9.528899601444923<br>


<br>


Gene 1<br>


max2.X3.v9.C0.exp.-.v0.v9.v0.v8.v3.v9.v6.v2.v1.v7.v6.v6.v0.v2.v3.v7.v6.v7.v3.v3.v1.v8.v7.v3.v8.v3.v7<br>


C0: 5.353542014548175<br>


C1: -9.236307382044629<br>


<br>


Gene 2<br>


gau.comp.*.v6.C1.*.v7.mul3.v6.C0.v1.v2.v6.v8.v3.v3.v5.v2.v6.v9.v6.v1.C1.v0.v4.v2.v0.v2.v9.v3.C0.v8.v9<br>


C0: 9.111412390259325<br>


C1: 9.94532215973475<br>


<br>


exp(-pow((1-(v7*(-9.528899601444923))),2)) +
max((5.353542014548175^3),v9) + exp(-pow((1-(v6*9.94532215973475)),2))<br>


<br>


&nbsp;&nbsp;&nbsp; ...<br>


<br>


Generation: 238<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 934.1794<br>


Linking function: +<br>


Gene 0<br>


-.v9.v8.sech.v1.v7.v9.v4.v7.C1.v2.v0.v3.v8.v3.v1.v5.v8.v8.v2.v8.v6.v2.v9.v2.v2.v1.v7.v8.v7.v0.v0.C0<br>


C0: -1.8928414198253574<br>


C1: 4.140535916050434<br>


<br>


Gene 1<br>


sin.min3.avg2.v2.v9.v8.v5.v0.v5.v8.v2.v9.v8.v8.v3.v0.v5.v5.v3.C1.v2.v0.v6.v9.v9.v2.v7.v5.C1.v8.v7.v0.v6<br>


C0: 7.570619662652462<br>


C1: -1.542568610489699<br>


<br>


Gene 2<br>


max2.v9.v9.acsc.v7.v8.add3.tan.v4.v0.v0.v0.v8.C1.v1.v3.v5.v2.v8.v2.v5.v9.v2.v5.v4.v1.v2.v8.v7.v6.v0.v5.C0<br>


C0: -9.226903090150953<br>


C1: 0.7626090735460895<br>


<br>


(v9-v8) + sin(min(((v8+v5)/2),v2,v9)) + max(v9,v9)<br>


<br>


&nbsp;&nbsp;&nbsp; ...<br>


<br>


Best Individual of Run:<br>


Found at Generation: 4293<br>


Evaluated: T<br>


Fitness: 936.5758<br>


Linking function: +<br>


Gene 0<br>


-.v9.v8.v0.v9.v7.acsc.v8.v2.v0.v3.v2.C1.v4.C0.v5.v9.v3.v5.v0.v2.v7.v7.v5.v9.v6.v2.v9.v2.v3.v9.v5.v5<br>


C0: 5.233037180754705<br>


C1: -7.143261425650365<br>


<br>


Gene 1<br>


sin.min3.mul3.v2.v6.cot.v6.mul4.v3.v6.v9.v8.v9.v5.v3.v0.v0.v0.v9.v5.v6.v0.v8.v4.v2.v8.v5.v4.v1.v0.C1.v5.v5<br>


C0: 3.8794116272712955<br>


C1: 7.460702927280668<br>


<br>


Gene 2<br>


v9.*.v8.v9.v8.v2.v7.*.v6.v4.v2.v7.v1.v9.v8.v8.v2.v6.v1.v8.v3.C0.v3.v3.v2.C0.C0.v9.v4.v2.v2.v7.v0<br>


C0: 1.24681550366709<br>


C1: -0.13544436934751047<br>


<br>


<span style="font-weight: bold;">(v9-v8) +
sin(min((cot(v3)*v6*(v6*v9*v8*v9)),v2,v6)) + v9</span><br>


<br>


Size of program: 17<br>


Variables used(count): v2(1), v3(1), v6(3), v8(2), v9(4)<br>


<br>


***** TRAINING data results *****<br>


Statistics: <br>


MSE:&nbsp; 24.239096329510474&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;RAE:&nbsp;
0.06769687388092159&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;RSE:&nbsp; 0.004585892048274829<br>


RMSE: 4.923321676420349&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; MAE:&nbsp;
4.017510790472716&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; RRSE: 0.06771921476416298<br>


<br>


<br>


***** TEST data results *****<br>


Number of Calculation Errors: 0 out of 10 test sets<br>


Statistics: <br>


MSE:&nbsp; 16.72184789340559&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; RAE:&nbsp;
0.11520996098236828&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;RSE:&nbsp; 0.019535079218796565<br>


RMSE: 4.089235612361508&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; MAE:&nbsp;
3.011454736524365&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; RRSE: 0.13976794775196696<br>


<br>


Observed&nbsp;&nbsp;&nbsp; Computed<br>


811.63994&nbsp;&nbsp;&nbsp; 808.827861961812<br>


797.92192&nbsp;&nbsp;&nbsp; 797.2229981918084<br>


786.41891&nbsp;&nbsp;&nbsp; 785.1324338242816<br>


771.09691&nbsp;&nbsp;&nbsp; 774.3511732579256<br>


763.19992&nbsp;&nbsp;&nbsp; 756.108499923999<br>


<br>


&nbsp;&nbsp;&nbsp; ...<br>


<br>


858.957&nbsp;&nbsp;&nbsp; 853.8591859872175<br>


869.964&nbsp;&nbsp;&nbsp; 871.6444114907323<br>


878.539&nbsp;&nbsp;&nbsp; 880.63390351821<br>


<br>


890.288&nbsp;&nbsp;&nbsp; 886.6045236016611<br>


900.373&nbsp;&nbsp;&nbsp; 901.3867552973694<br>


916.525&nbsp;&nbsp;&nbsp; 910.849758599105<br>


932.277&nbsp;&nbsp;&nbsp; 932.416393052961<br>


947.579&nbsp;&nbsp;&nbsp; 947.2086536125466<br>


960.562&nbsp;&nbsp;&nbsp; 962.9643013882095<br>


966.205&nbsp;&nbsp;&nbsp; 973.9101611582124<br>


970.634&nbsp;&nbsp;&nbsp; 970.9536648254193<br>


972.626&nbsp;&nbsp;&nbsp; 974.1782314966911<br>


968.324&nbsp;&nbsp;&nbsp; 975.5769759596939</code></small><br>


<br>


<span style="font-weight: bold;">2. Exchange Rate Example</span>
- This example follows the exchange rate of the Australian dollar
against the US dollar. The original time series data file USEXCHM.DAT
can be obtained from:<br>


<br>


&nbsp;&nbsp;&nbsp; Hyndman, R.J. (n.d.) Time Series Data
Library, http://www.robhyndman.info/TSDL/. <br>


&nbsp;&nbsp;&nbsp; Accessed on June 3, 2006.<br>


<br>


For the integral time series used in this run, each value from the last
100 records of&nbsp;the original raw series was replaced by its
moving average using a smoothing period p = 12.<br>


<br>


<span style="font-weight: bold;">3. Earthquake Data Example</span>
- This example follows the number of earthquakes per year of magnitude
7.0 or greater from 1900 to 1998. The source is the US National
Earthquake Information Center and the original time series data file
EARTHQ.DAT can be obtained from:<br>


<br>


&nbsp;&nbsp;&nbsp; Hyndman, R.J. (n.d.) Time Series Data
Library, http://www.robhyndman.info/TSDL/. Accessed on June 3, 2006.<br>


<br>


For the integral time series used in this run, each value from original
raw series was&nbsp;replaced by its moving average using a
smoothing period p = 10.<br>


<br>


<span style="font-weight: bold;">4. Sunspost Data Example</span>
- This example uses the Wolfer sunspots data that can be found at
http://mason.gmu.edu/~csutton/sun554.html or do a search on the
internet. For this example we have 3 variations to show how the
timeseries files can be accessed. The Sunspots.param variation gets the
data from a timeseries text file, Sunspots.txt. Sunspots2.param gets
the data from a user program. Sunspots3.param get the data from a text
file but it is preprocessed already, so one should not specify the
delay, or other 2 parameters that are required when the data must be
processed.<br>


<br>


</p>


<br>


<br>


<h1><a name="Logical_Problem_Examples"></a>Logical Problem Examples</h1>


<br>


<p class="MsoNormal">Logical problems have data values
that are all&nbsp;logical, i.e. true or false (represented by 1 and
0 in
gep). They can use only logical functions such as <span style="font-weight: bold;">and</span>, <span style="font-weight: bold;">or</span>, <span style="font-weight: bold;">not</span>, etc.
and the linking function must be a logical function as well (from the
list: <span style="font-weight: bold;">and</span>, <span style="font-weight: bold;">or</span>, <span style="font-weight: bold;">nand</span>, <span style="font-weight: bold;">nor</span>, <span style="font-weight: bold;">xor</span>, <span style="font-weight: bold;">nxor</span>).&nbsp;<br>


<br>


<span style="font-weight: bold;">1. XOR example</span>
- Given a set of x, y and result values (where the result is the <span style="font-weight: bold;">exclusive or</span> of the
x and y values) we try to discover an equivalent function using only
the
functions <span style="font-weight: bold;">and</span>,
<span style="font-weight: bold;">or</span> and <span style="font-weight: bold;">not</span>. The Xor.param
file contains:</p>


<br>


<code><small>gep.species.numgenes = 2<br>


gep.species.gene-headsize = 8<br>


gep.species.problemtype = logical<br>


gep.species.symbolset.terminalfilename = ec/gep/test/Xor.txt<br>


gep.species.symbolset.functionsize = 3<br>


gep.species.symbolset.function.0 = Not<br>


gep.species.symbolset.function.0.weight = 1<br>


gep.species.symbolset.function.1 = And<br>


gep.species.symbolset.function.1.weight = 1<br>


gep.species.symbolset.function.2 = Or<br>


gep.species.symbolset.function.2.weight = 1<br>


</small></code>
<br>


<p class="MsoNormal">The resulting statistic
file shows that an
expression was discovered that matches the requirement exactly.<br>


<br>


<small><code>Seed(s) used in this job: 4357<br>


Problem Type: logical<br>


<br>


Generation: 0<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 500.0<br>


Linking function: and<br>


Gene 0<br>


not.and.d1.and.d1.d0.not.d0.d0.d0.d0.d1.d1.d0.d0.d1.d1<br>


Gene 1<br>


not.and.d0.d1.d0.d1.d0.d1.d0.d0.d0.d0.d1.d0.d1.d0.d0<br>


<br>


(not (d1 and (d1 and d0))) and (not (d0 and d1))<br>


<br>


Generation: 2<br>


Best Individual:<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: and<br>


Gene 0<br>


not.and.d0.d1.d0.and.d1.not.d0.d1.d1.d0.d0.d1.d1.d0.d0<br>


Gene 1<br>


or.d0.or.d1.d1.not.not.not.d1.d0.d0.d1.d0.d0.d1.d0.d0<br>


<br>


(not (d0 and d1)) and (d0 or (d1 or d1))<br>


<br>


Best Individual of Run:<br>


Found at Generation: 2<br>


Evaluated: T<br>


Fitness: 1000.0<br>


Linking function: and<br>


Gene 0<br>


not.and.d0.d1.d0.and.d1.not.d0.d1.d1.d0.d0.d1.d1.d0.d0<br>


Gene 1<br>


or.d0.or.d1.d1.not.not.not.d1.d0.d0.d1.d0.d0.d1.d0.d0<br>


<br>


(not (d0 and d1)) and (d0 or (d1 or d1))<br>


<br>


Size of program: 9<br>


Variables used(count): d0(2), d1(3)<br>


<br>


***** TRAINING data results *****<br>


Confusion Matrix: <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Predicted Value<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|&nbsp; Yes&nbsp;&nbsp;&nbsp;|&nbsp; No<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Yes|&nbsp; 2&nbsp;&nbsp;&nbsp; &nbsp;|&nbsp; 0<br>


Actual Value&nbsp;&nbsp; |----------------<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
No |&nbsp; 0&nbsp;&nbsp;&nbsp; &nbsp;|&nbsp; 2<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
|----------------<br>


<br>


Observed&nbsp;&nbsp;&nbsp; Computed<br>


0.0&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;0.0<br>


1.0&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1.0<br>


1.0&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;1.0<br>


0.0&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; 0.0</code></small><br>


<br>


<span style="font-weight: bold;">2. Majority Function
Example</span> - This example looks for a logical expression that
can determine if given three inputs (x, y and z) there are at least 2
true (1) values. The solution uses only the operators <span style="font-weight: bold;">not</span>, <span style="font-weight: bold;">and</span> and <span style="font-weight: bold;">or</span>.<br>


<br>


<span style="font-weight: bold;">3. Odd 3-Parity Example</span>
- This example looks at 3 boolean input variables (x, y, and z) and
looks for a logical expression that can decide if there are an
odd&nbsp;number of true (1) values. The solution uses only the
operators <span style="font-weight: bold;">not</span>,
<span style="font-weight: bold;">and</span> and <span style="font-weight: bold;">or</span>.<br>


<br>


<span style="font-weight: bold;">4. 6
Bit&nbsp;Multiplexer Example</span> - This example is an
attempt to discover a 6 bit multiplexer function using <span style="font-weight: bold;">and</span>, <span style="font-weight: bold;">or</span> and <span style="font-weight: bold;">not</span> operators. It
looks at 6 boolean variables representing 2 control bits and&nbsp;4
data bits. The 1st 2 bits are the control bits and they identify
which&nbsp;of the next 4 input bits will be in the output. For
example, if the&nbsp;control bits are 00 then the 3rd bit value is
value of the output;&nbsp;if the control bits are 01 then the 4th
bit value is the output value;&nbsp;if the control bits are 10 then
the 5th bit value is the output value;&nbsp;if the control bits are
11 then the 6th bit value is the output value.&nbsp;This can be
expressed as:<br>


<br>


&nbsp;&nbsp;&nbsp; A&amp;~c1&amp;~c2 v
B&amp;~c1&amp;c2 v C&amp;c1&amp;~c2 v
D&amp;c1&amp;c2 = output<br>


<br>


&nbsp;&nbsp;&nbsp; where c1 is control bit 1 and c2 is
control bit 2<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp; A, B, C, D are the 4 input
bits<br>


<br>


So if we have 6 bits labelled d0, d1, d2, d3, d4, d5 and d0=c1, d1=c2,
A=d2, B=d3, C=d4, D=d5 then an excellent solution to the problem will
be:<br>


<br>


&nbsp;&nbsp;&nbsp; output = d2&amp;~d0&amp;~d1 v
d3&amp;~d0&amp;d1 v d4&amp;d0&amp;~d1 v
d5&amp;d0&amp;d1<br>


</p>


<br>


<h1><a name="A_Detailed_Look_at_the_GEP_Parameter"></a>
A Detailed Look at the GEP Parameter File (gep.params)</h1>


<br>


The file ec/gep/gep.params has most of the required details in
comments. But here we list the parameter settings that are of concern
for gep problems.<br>


<br>


<span style="font-weight: bold;">eval.problem</span>
- The user code to support the problem. For example, ec.app.gep.test2.test2.
These classes will be of type GEPProblem.&nbsp;If the user wants to
just take a default route and not have to create any code at all he can
use the default GEPProblem class, ec.gep.GEPDefaultUserProb. Then he
will need to also specify a 'fitness-function'&nbsp;to use by
setting the parameter <span style="font-weight: bold;">eval.problem.fitness-function
</span>and possibly one or both of the parameters&nbsp;<span style="font-weight: bold;">eval.problem.fitness-function-arg0</span>
and <span style="font-weight: bold;">eval.problem.fitness-function-arg1</span>.&nbsp;<br>


<br>


<span style="font-weight: bold;">evalthreads</span>
and <span style="font-weight: bold;">breedthreads</span>
&nbsp;- should both be 1 always. It's possible to have multiple
threads but it would NOT work as per the GeneXProTools system and I
expect the code as is now will not work (at tleast the code would need
to be modified so an adjustment is made so that the multiple paths
through breeding &nbsp;would each reduce the rates for inversion,
mutaition, etc.)<br>


<br>


<span style="font-weight: bold;">checkpoint</span> -
not well tested but it should work OK. If not let me know. May not be
important since rerunning a problem may be fast enough.<br>


<span style="font-weight: bold;">state</span> -
Should be ec.simple.SimpleEvolutionState; <span style="font-weight: bold;">do not change this!</span><br>


<span style="font-weight: bold;">init</span> -
Should be ec.gep.GEPInitializer; probably should not need to change
this.<br>


<span style="font-weight: bold;">finish</span> -
Should be ec.simple.SimpleFinisher; probably should not need to change
this.<br>


<span style="font-weight: bold;">exch</span> -
Should be ec.simple.SimpleExchanger; probably should not need to change
this.<br>


<span style="font-weight: bold;">breed</span>
-Should be ec.simple.SimpleBreeder;<span style="font-weight: bold;">
do not change this.<br>


eval</span> - Should be ec.simple.SimpleEvaluator; do not change
this without some serious thought.<br>


<span style="font-weight: bold;">generations</span>
- As for standard ecj.<br>


<span style="font-weight: bold;">quit-on-run-complete</span>
- As for standard ecj.<br>


<br>


<span style="font-weight: bold;">pop</span> - Should
be ec.Population. - As for standard ecj.<br>


<span style="font-weight: bold;">pop.subpops</span>
- must be set to 1 (<span style="font-weight: bold;">do
not change</span> since only 1 subpop makes sense).<br>


<span style="font-weight: bold;">pop.subpop.0</span>
- must be ec.Subpopulation. <span style="font-weight: bold;">Do
not change</span>.<br>


<span style="font-weight: bold;">pop.subpop.0.fitness</span>
- Should be ec.simple.SimpleFitness. could change this as required (for
example to support a more complex fitess or to use doubles rather than
floats).<br>


<span style="font-weight: bold;">pop.subpop.0.duplicate-retries</span>
- should be 0? Haven't looked closely at this.<br>


<span style="font-weight: bold;">pop.subpop.0.size</span>
- application dependent.<br>


<br>


<span style="font-weight: bold;">pop.subpop.0.species</span>
- must be ec.gep.GEPSpecies.<br>


<span style="font-weight: bold;">pop.subpop.0.species.ind</span>
- must be ec.gep.GEPIndividual.<br>


<br>


The following are the standard defaults for the evolutionary parameters
as suggested by Ferreira. these can be changed as required. I called
these probabilities but they are actually 'rates' the way Ferreira uses
them. If they were probabilities as I first thought then the number of
affected individuals in each generation would vary according to the
probability. But instead these rates are used to determine the number
of individuals that will be affected in every generation (constant).
The individuals are randomely chosen.<br>


<span style="font-weight: bold;">gep.species.inversion-prob</span>&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp; &nbsp; = 0.1<br>


<span style="font-weight: bold;">gep.species.mutation-prob&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; </span>&nbsp;
&nbsp;&nbsp; = 0.044<br>


<span style="font-weight: bold;">gep.species.istransposition-prob</span>&nbsp;&nbsp;
&nbsp; &nbsp; = 0.1<br>


<span style="font-weight: bold;">gep.species.ristransposition-prob&nbsp;
&nbsp; &nbsp; </span>= 0.1<br>


<span style="font-weight: bold;">gep.species.onepointrecomb-prob&nbsp;
&nbsp;&nbsp; </span>= 0.3<br>


<span style="font-weight: bold;">gep.species.twopointrecomb-prob&nbsp;
&nbsp;&nbsp; </span>= 0.3<br>


<span style="font-weight: bold;">gep.species.generecomb-prob&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;</span>=
0.1<br>


<span style="font-weight: bold;">gep.species.genetransposition-prob</span>
&nbsp;= 0.1<br>


<br>


Constants can not be used with Logical problem types and will be
ignored if specified.<br>


<span style="font-weight: bold;">gep.species.use-constants</span>
- set to true if using constants else&nbsp;false.<br>


<span style="font-weight: bold;">gep.species.numconstantspergene</span>
- Number of constans generated for each gene.<br>


<span style="font-weight: bold;">gep.species.integer-constants</span>
- Set to true if using integer constants or false to use floating point
constants.<br>


<span style="font-weight: bold;">gep.species.constants-lowerlimit</span>
- Minimum value of the constants chosen.<br>


<span style="font-weight: bold;">gep.species.constants-upperlimit</span>
- Maximum value of the constants chosen.<br>


These are default to these values as suggested by Ferreira. They can be
changed as required for the problem, but will need to understand what
they mean (read the information in Ferreira's book, etc.)<br>


<span style="font-weight: bold;">gep.species.rnc-mutation-prob</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0.01<br>


<span style="font-weight: bold;">gep.species.dc-mutation-prob</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0.044<br>


<span style="font-weight: bold;">gep.species.dc-inversion-prob</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
= 0.1<br>


<span style="font-weight: bold;">gep.species.dc-istransposition-prob</span>&nbsp;&nbsp;
= 0.1<br>


<br>


<span style="font-weight: bold;">gep.species.numgenes</span>
- The number of genes to be used for the problem.<br>


<span style="font-weight: bold;">gep.species.gene-headsize</span>
- The length of the head of the gene.<br>


<br>


The linking function may be one of +, -, * or / for most problem types
except&nbsp;logic problems where it can be one of: and, or, nand,
nor, xor, nxor.<br>


<span style="font-weight: bold;">gep.species.gene-linking-function</span>
- The function to use when combining the values the expressions for
each gene.<br>


<br>


Problem type must be one of: functionfinding, classification,
timeseries, logical.&nbsp;Set default to be 'unknown' so user is
forced to specify in the problem params file.<br>


<span style="font-weight: bold;">gep.species.problemtype</span>
= unknown<br>


<br>


<span style="font-weight: bold;">gep.species.classification-threshold</span>
- If the problem is a <span style="font-weight: bold;">classification</span>
type problem then a threshold value (used&nbsp;to convert real
values to 0 or 1 during fitness calculations) must
be&nbsp;specified.<br>


<br>


If the problem type is timeseries then the user needs to specify a
number of parameters. See ec.gep.gep.params for full details.<br>


<span style="font-weight: bold;">gep.species.timeseries-delay&nbsp;</span><br style="font-weight: bold;">


<span style="font-weight: bold;">gep.species.timeseries-embeddingdimension</span><br style="font-weight: bold;">


<span style="font-weight: bold;">gep.species.timeseries-testingpredictions</span>&nbsp;<br>


<br>


<span style="font-weight: bold;">gep.species.symbolset</span>&nbsp;
- Must be ec.gep.GEPSymbolSet; <span style="font-weight: bold;">do
NOT change</span>.<br>


<span style="font-weight: bold;">gep.species.symbolset.name</span>
- can be any string but must be specified; not actually used (at one
point it seemed we might have multiple symbols sets but this will not
likely happen0; should be removed at some point.<br>


<br>


Examples for specifiying the functions to be used in the problem and
their weights. The set of functions can be found by looking at the
directory ec/.gep/symbols.<br>


<span style="font-weight: bold;">gep.species.symbolset.functionsize</span>
= 4<br>


<span style="font-weight: bold;">gep.species.symbolset.function.0</span>
= Add<br>


<span style="font-weight: bold;">gep.species.symbolset.function.0.weight</span>
= 1<br>


<span style="font-weight: bold;">gep.species.symbolset.function.1</span>
= Sub<br>


<span style="font-weight: bold;">gep.species.symbolset.function.1.weight</span>
= 1<br>


<span style="font-weight: bold;">gep.species.symbolset.function.2</span>
= Mul<br>


<span style="font-weight: bold;">gep.species.symbolset.function.2.weight</span>
= 1<br>


<span style="font-weight: bold;">gep.species.symbolset.function.3</span>
= Div<br>


<span style="font-weight: bold;">gep.species.symbolset.function.3.weight</span>
= 1<br>


<br>


The number and names of the terminal symbols (independent variables)
can be specified as shown below:<br>


<span style="font-weight: bold;">gep.species.symbolset.terminalsize
</span>= 1<br>


<span style="font-weight: bold;">gep.species.symbolset.terminal.0</span>
= x<br>


Or for the terminal set, the info can be in a text file where the
file&nbsp;has the names of the terminal symbols and the dependent
variable in the first record/line (comma separated (default)... or tab
separated, etc)&nbsp;and the training values for the terminal
symbols in the other&nbsp;records; the number of terminals is
computed from the number of
terminal symbols in the 1st record. See details in ec/gep/gep.params
and look at some examples.<br>


<span style="font-weight: bold;">gep.species.symbolset.terminalfilename</span>
= filename<br>


<span style="font-weight: bold;">gep.species.symbolset.terminalfileseparator</span>
= ,<br>


or for a tab<br>


<span style="font-weight: bold;">gep.species.symbolset.terminalfileseparator</span>
= tab<br>


<br>


If there is testing data as well it can be specified. Again see full
details in ec/gep/gep.params since there are some slightly complex
situations (timeseries data etc.).<br>


<span style="font-weight: bold;">gep.species.symbolset.testingterminalfilename</span>
= testDataFileName<br>


<br>


For gep systems breeding should be as shown below. Changing theseis
possible but will not be as per original gep by Ferreira (as in
GeneXProTools) and will require some in-depth knowledge!<br>


<span style="font-weight: bold;">gep.species.pipe</span>
= ec.gep.breed.DcGeneticOperatorsPipeline<br>


<span style="font-weight: bold;">gep.dcgeneticoperators.source.0</span>
= ec.gep.breed.GenerecombinationPipeline<br>


<span style="font-weight: bold;">gep.generecombination.source.0</span>
=
ec.gep.breed.TwopointrecombinationPipeline<br>


<span style="font-weight: bold;">gep.twopointrecombination.source.0</span>
=
ec.gep.breed.OnepointrecombinationPipeline<br>


<span style="font-weight: bold;">gep.onepointrecombination.source.0</span>
=
ec.gep.breed.GenetranspositionPipeline<br>


<span style="font-weight: bold;">gep.genetransposition.source.0</span>
= ec.gep.breed.RIStranspositionPipeline<br>


<span style="font-weight: bold;">gep.RIStransposition.source.0</span>
= ec.gep.breed.IStranspositionPipeline<br>


<span style="font-weight: bold;">gep.IStransposition.source.0</span>
= ec.gep.breed.InversionPipeline<br>


<span style="font-weight: bold;">gep.inversion.source.0</span>
= ec.gep.breed.MutationPipeline<br>


# FitProportionateSelection (roulette selection) is used exclusively by Ferreira - could be changed<span style="font-weight: bold;"><br>gep.mutation.source.0 = </span>ec.select.FitProportionateSelection<span style="font-weight: bold;"><br></span><br>


<span style="font-weight: bold;">breed.elite.0 </span>-
Should be set to 1 since this is the only option used by ferreira;
however you might want to experiment with this to see if it improves
the evolution for your problem.<br>


<br>


We supply a not so simple GEPSimpleStatistics class to handle the basic
capture of information from a gep run. For the basic setting of
statistics output you can do something like the following.<br>


<span style="font-weight: bold;">stat</span> =
ec.gep.GEPSimpleStatistics<br>


<span style="font-weight: bold;">stat.file</span> =
ourProblem.stat<br>


<span style="font-weight: bold;">stat.file-observed-versus-computed</span>
= ourOvsC.stat<br>


<span style="font-weight: bold;">stat.file-observed-versus-computed-test</span>
= ourOvsCtest.stat<br>


<span style="font-weight: bold;">stat.detail-to-log</span>
= change<br>


This contains all of the parameters that you might like to use but
variations can be done depending what you want to capture. As shown
above, GEPSimpleStatistics has a number of parameters it&nbsp;can
use to control the output:<br>


<span style="font-weight: bold;">stat.file </span>-
The main output is directed to the file
specified by the file param<br>


<span style="font-weight: bold;">file-observed-versus-computed</span>
- this file, if
specified, gets the results&nbsp;of the best of run model by
listing the observed values versus&nbsp;the model's predicted
values (useful for plotting). By default this&nbsp;will include the
training and testing data values (with test values&nbsp;appended to
the end if they exist). To get the training and testing&nbsp;values
separated identify a second file in the parameter:<br>


<span style="font-weight: bold;">file-observed-versus-computed-test</span>.
If <span style="font-weight: bold;">file-observed-versus-computed</span>
is<span style="font-weight: bold;"> </span>not
specified it prints to the&nbsp;main output file if specified or to
the console.<br>


<span style="font-weight: bold;">file-observed-versus-computed-test</span>
- If
specificed, this identifies a&nbsp;file with only the test data. If
not specified it prints to the console.<br>


<span style="font-weight: bold;">no-observed-versus-computed</span>
- If true then don't
print any observed/computed values&nbsp;even if files are specified.<br>


<span style="font-weight: bold;">detail-to-log</span>
- the user can specify the detail
of the output to the main
log file (param 'stat.file'). Values can be one of:<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;<span style="font-weight: bold;">all</span> - display the
best model from every generation (can be a
large&nbsp;amount of output)<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">change</span> - logs the
best model of the generation when the fitness
improves (default)<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <span style="font-weight: bold;">final</span> - logs only
the best of run model information<br>


<br>


More complex things can be done as per standard ECJ. Consider the
example below examples for setting multiple statistic packages.<br>


stat.num-children = 3<br>


stat.child.0 = ec.gep.test.SimpleXYSeriesChartStatistics<br>


stat.child.0.title = Best of Generation<br>


stat.child.0.x-axis-label = generation<br>


stat.child.0.y-axis-label = fitness<br>


stat.child.1 = ec.simple.SimpleShortStatistics<br>


stat.child.1.file = simpleshortstats.txt<br>


stat.child.1.gather-full = true<br>


stat.child.2 = ec.gep.GEPSimpleStatistics<br>


stat.child.2.file = simplestats.txt<br>


stat.child.2.file-observed-versus-computed = simplestatsOvsC.txt<br>


<br>


<br>


<h1><a name="Some_of_the_Implementation_Details"></a>Some
of the
Implementation Details<br>


<br>


<span style="font-weight: normal;">The system has been
tested using <span style="font-weight: bold;">Java
version 1.5</span>.</span><br>


<br>


<span style="font-weight: normal;">One thing to note about
the gep implementation is that <span style="font-weight: bold;">all
values are
double</span>, rather than float as in other ECJ parts. The only
thing not in
double is the fitness and this only because we used the SimpleFitness
provided with ecj. When complicated expressions are created during the
evolution, considerable loss of precision creeps in when they are
evaluated as floats rather than doubles. The penalty may be a loss of
speed but I don't think it's too great. The gep implementation is still
quite speedy and we've done a few demanding examples (50 individuals in
the population, 5 genes, head size of 15, 2 constants per gene, 13
functions, 25000 generations) and the performance is quite acceptable.
Try some of the examples or your own problems and I think you'll see
that the performance is quite good. Note also that the logical
problems, although they use only values 0 and 1 are still done with
double values. This could be much improved I suppose,&nbsp; but no
effort has been made to do so. It works fairly quickly as is and these
are not problems we were all that interested in for our research.<br>


<br>


This is the first version of this gep extension and the code could use
some reorganization, optimization and perhaps better adherance to the ECJ
structures (although it isn't too bad).</span><br style="font-weight: normal;">


<br style="font-weight: normal;">


<span style="font-weight: normal;"><a name="ModsToExistingECJcode"></a>I did modify a couple
of the standard ECJ files. These were very minor modifications.
First&nbsp; the <span style="font-weight: bold;">ec.display.Console</span>
was changed slightly to fix a problem with being able to control the
parameters (visible in the interface) properly. This required the
addition of 1 line of code around line 1050 (in the run method):<br>


<br>


<small><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;conPanel.enableControls();
// this line added<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finishAndCleanup();</code></small></span><small><code><br>


</code></small><br style="font-weight: normal;">


<span style="font-weight: normal;">A second change in
ec.display.Console was to allow the seed that is used in a run to be
stored for access later in statistics output. This also required some
changes to other files (below). The change was near line 927 in
initializeEvolutionState:<br>


<br>


<small><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
state.evalthreads = evalthreads;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.breedthreads
= breedthreads;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;state.seeds
= seeds; &nbsp;// this line added</code></small></span><br>


<br>


<span style="font-weight: normal;">The other changes were
made to files <span style="font-weight: bold;">ec.Evolve</span>
and <span style="font-weight: bold;">ec.EvolutionState </span>to
support the need to have access to the seed value(s) for reporting in
statistics. This is important so that one can rerun the program with
the same seed at some later time and there was no way to record this in
the current version of ECJ. in ec.Evolve near line 320 we added the
code:<br>


<br>


<small><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
state.breedthreads = breedthreads;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
state.randomSeedOffset = randomSeedOffset;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
state.seeds = seeds; &nbsp;// line was added<br>


</code></small><br>


and near line 200 in ec.EvolutionState we added the code:<br>


<br>


<small><code>&nbsp;&nbsp;&nbsp; /**<br>


&nbsp;&nbsp;&nbsp;&nbsp; * The seeds used for the
current job<br>


&nbsp;&nbsp;&nbsp;&nbsp; */<br>


&nbsp;&nbsp;&nbsp; public int seeds[];</code></small><br>


<br><br>


<a name="AddingNewFunctions"></a>The two areas where
users might want to add functionality to this gep
implementation are <span style="font-weight: bold;">new
mathematical/logical functions</span> and <span style="font-weight: bold;">new fitness functions</span>.
All mathematical functions are derived from the abstract class
GEPFunctionSymbol. Any new function will have to provide just a few
simple methods. Let's look at the Add function.<br>


<br>


<small><code>package ec.gep.symbols;<br>


import ec.EvolutionState;<br>


import ec.gep.GEPFunctionSymbol;<br>


import ec.gp.GPData;<br>


import ec.gp.GPIndividual;<br>


import ec.util.Parameter;<br>


<br>


public class Add extends GEPFunctionSymbol {<br>


<br>


&nbsp;&nbsp;&nbsp; public Add() <br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;
super("+", 2);<br>


&nbsp;&nbsp;&nbsp; }<br>


<br>


&nbsp;&nbsp;&nbsp; public double eval(double params[]) <br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; //should
check that there are 2 params<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
(params[0] + params[1]);<br>


&nbsp;&nbsp;&nbsp; }<br>


&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; public boolean isLogicalFunction()<br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
false;<br>


&nbsp;&nbsp;&nbsp; }<br>


<br>


&nbsp;&nbsp;&nbsp; public String printMathExpression(
String p[] )<br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
"(" + p[0] + "+" + p[1] + ")";<br>


&nbsp;&nbsp;&nbsp; }<br>


}</code></small></span></h1>


<br>


The constructor will simply call the super constructor and pass the
symbol to be used when printing the Karva representation of the
expressions formed in the genes. It will also pass the 'arity' of the
function (how many arguments it needs when executed). It must also
implement an <span style="font-weight: bold;">eval</span>
method to calculate it's value using the arguments passed to it. As the
comment says some checking could (should?) be done to ensure there are
2 arguments available in the params array, but this is probably not the
place to do it. It should be done in the place where eval is called so
every function doesn't have to do it (i.e. in the eval method of
GEPExpressionTreeNode). There are places where it is necessary to know
if this is a logical function or not (so we can ensure that logical
problems use on ly logical functions and other problem types don't use
logical functions. so we must provide the simple isLogicalFunction
method. Finally in order to display the expressions in a mathematical
notation it is necessary for the function to provide an appropriate
string representation for this purpose. I'd suggest looking at a
similar function to see how it was done and proceed from there. The
array passed to printMathExpression contains the string representations
of it's parameters.<br>


<br>


Adding <span style="font-weight: bold;">new fitness
functions</span> is done by adding some methods to the class
ec.gep.GEPFitnessFunction. For each of the fitness functions there are
3 methods that need to be supplied: one to calculate the
fitness&nbsp;(with a value from 0 to some maximum); one to give the
raw fitness value, the value prior&nbsp;to being mapped between 0
and the maximum value; and one to provide the maximum value that the
fitness value can take for that fitness function. Actually the raw
value is not always needed (see for example the specialized fitness
function WCorrRMSE (Weighted correlation coefficient and Root Mean
Squared Error). There is no raw value for this since it combines to
other fitness values. but since some users might want access to the
value before it is converted to a value from 0 to a maximum value, it
seemed prudent to make this available whenever possible. By convention
we use the names XXXXfitness, XXXXrawFitness&nbsp;and
XXXXmaxFitness for all of the fitness functions. XXXX is the pneumonic
for the&nbsp;fitness function (e.g. RRSE, MAE, etc.). This allows a
user to specifiy a fitness function to be&nbsp;used in the default
user program by specifying only the short pneumonic for the fitness
function (they don't provide ANY code if they use this - check the code
in GEPDefaultUserProg.java). The XXXXmaxFitness functions all have 1
arg when most don't need one.&nbsp;This was just to make it
consistent and easier to call the method based on the XXXX part only
(again see&nbsp;GEPDefaultUserProg.java).&nbsp;For example the
functions for the MSE fitness functions are called as:<br>


<br>


<small><code>&nbsp; &nbsp;&nbsp;&nbsp;
GEPFitnessFunction.MSEfitness( gepindividual );<br>


&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; - calculates the fitness using the
individual's gene expressions<br>


&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; - it gets the raw fitness first from
MSErawFitness (the mean squared error<br>


&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp; of the predicted values
versus the text/expected values)<br>


&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; - then it normalizes the result between
0 and 1000&nbsp; <br>


&nbsp; &nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; (1000 *
(1/(1 + raw MSE))<br>


&nbsp; &nbsp;&nbsp;&nbsp;
GEPFitnessFunction.MSErawFitness( gepindividual );<br>


&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
- sum((predicted valuei - expected valuei)**2)/n<br>


&nbsp; &nbsp;&nbsp;&nbsp;
GEPFitnessFunction.NHmaxFitness( gepindividual );<br>


&nbsp;&nbsp; &nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; - in this case max is always 1000 but
some fitness functions<br>


&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; have
a maximum that depends on the number of training data sets<br>


</code></small><br>


Again let's look at a the code of a fitness function to see what's
required.<br>


<br>


<code><small>&nbsp;&nbsp;&nbsp;
//*************************
RAE (Relative Absolute Error) *****************<br>


&nbsp;&nbsp;&nbsp; /**<br>


&nbsp;&nbsp;&nbsp; &nbsp;* Calculates the 'raw' fitness
for the RAE (Relative Absolute Error) type <br>


&nbsp;&nbsp;&nbsp; &nbsp;* fitness (before the
normalization from 0 to max value is done).<br>


&nbsp;&nbsp;&nbsp; &nbsp;* @param ind the GEP
individual that needs its fitness calculated.<br>


&nbsp;&nbsp;&nbsp; &nbsp;* @return the 'raw' fitness
value before normalization from 0 to max value<br>


&nbsp;&nbsp;&nbsp; &nbsp;*/<br>


&nbsp;&nbsp;&nbsp; public static double
RAErawFitness(GEPIndividual ind) <br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double sumOfAbsoluteError = 0.0;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double expectedResult;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double result;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double error;<br>


<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double dependentVar[] =
GEPDependentVariable.getDependentVariableValues();<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double dvSumOfAbsoluteError =
GEPDependentVariable.getDependentVariableSumOfAbsoluteError();<br>


<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i=0; i&lt;dependentVar.length; i++)<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{ &nbsp; expectedResult = dependentVar[i];<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
result = ind.eval(i);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
error = result - expectedResult;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
sumOfAbsoluteError += Math.abs(error); <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (dvSumOfAbsoluteError == 0.0)<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{&nbsp;&nbsp; dvSumOfAbsoluteError = RELATIVE_ERROR_ZERO_FACTOR;<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; System.err.println("Warning: sum of
error for dependent variable is 0 in RAE fitness calculation. Adjusting
to avoid division by zero.");<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// the raw fitness ... RAE<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (sumOfAbsoluteError/dvSumOfAbsoluteError);<br>


&nbsp;&nbsp;&nbsp; }<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; <br>


&nbsp;&nbsp;&nbsp; /**<br>


&nbsp;&nbsp;&nbsp; &nbsp;* Calculates the fitness for
the RAE (Relative Absolute Error) type fitness. <br>


&nbsp;&nbsp;&nbsp; &nbsp;* Gets the raw fitness and
then normalized between 0 and max value.<br>


&nbsp;&nbsp;&nbsp; &nbsp;* @param ind the GEP
individual that needs its fitness calculated.<br>


&nbsp;&nbsp;&nbsp; &nbsp;* @return the 'raw' fitness
value before normaization from 0 to max value<br>


&nbsp;&nbsp;&nbsp; &nbsp;*/<br>


&nbsp;&nbsp;&nbsp; public static double
RAEfitness(GEPIndividual ind) <br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
double RAE = RAErawFitness(ind);<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
// raw fitness is normalized between 0 and 1000&nbsp; (1000 *
(1/(1+RAE))<br>


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return (1000.0)/(1.0+RAE);<br>


&nbsp;&nbsp;&nbsp; }<br>


<br>


&nbsp;&nbsp;&nbsp; /**<br>


&nbsp;&nbsp;&nbsp; &nbsp;* The max value for this type
of fitness is always 1000.<br>


&nbsp;&nbsp;&nbsp; &nbsp;* @param ind the GEP
individual that needs its fitness calculated.<br>


&nbsp;&nbsp;&nbsp; &nbsp;* @return value 1000.0<br>


&nbsp;&nbsp;&nbsp; &nbsp;*/<br>


&nbsp;&nbsp;&nbsp; public static double
RAEmaxFitness(GEPIndividual ind) <br>


&nbsp;&nbsp;&nbsp; {<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; // always
1000<br>


&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; return
1000.0;<br>


&nbsp;&nbsp;&nbsp; }</small>
<br>


</code>
<p>The code is fairly straight forward. the only thing to note is
that at one point we accessed the sum of the absolute error of the
values of the dependent variable data in the training set using -
GEPDependentVariable.getDependentVariableSumOfAbsoluteError().
When the training and testing data for the program is obtained, a
number of values are calculated and stored statically in the class
GEPDependentVariable. This is so these values, which are used by
several fitness functions, don't have to be recalculated many times as
the evolutionary process measures the fitness of many individuals. The
values available for use in the fitness functions are:</p>


<code><small>&nbsp;&nbsp;&nbsp;
/** Mean value of the training values for the dependent variable */<br>


&nbsp;&nbsp;&nbsp; static double dependentVariableMean =
0.0;<br>


&nbsp;&nbsp;&nbsp; /** Sum of the absolute error between
dependent variables training values and their mean value. The<br>


&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; absolute error is
Abs(dv[i] - dvMean).<br>


&nbsp;&nbsp;&nbsp;&nbsp; */<br>


&nbsp;&nbsp;&nbsp; static double
dependentVariableSumOfAbsoluteError = 0.0;<br>


&nbsp;&nbsp;&nbsp; /** Sum of the squares of the absolute
errors between dependent variables training values and their mean <br>


&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; value. The
absolute error is Abs(dv[i] - dvMean).<br>


&nbsp;&nbsp;&nbsp;&nbsp; */<br>


&nbsp;&nbsp;&nbsp; static double
dependentVariableSumOfSquaredAbsoluteError = 0.0;<br>


&nbsp;&nbsp;&nbsp; /** Sum of the relative errors between
dependent variables training values and their mean value.<br>


&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; The relative error
is Abs((dv[i] - dvMean)/dvMean).<br>


&nbsp;&nbsp;&nbsp;&nbsp; */<br>


&nbsp;&nbsp;&nbsp; static double
dependentVariableSumOfRelativeError = 0.0;<br>


&nbsp;&nbsp;&nbsp; /** Sum of the squares relative errors
between dependent variables training values and their mean value.<br>


&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; The relative error
is Abs((dv[i] - dvMean)/dvMean).<br>


&nbsp;&nbsp;&nbsp;&nbsp; */<br>


&nbsp;&nbsp;&nbsp; static double
dependentVariableSumOfSquaredRelativeError = 0.0;<br>


<br>


</small></code>
<p class="MsoNormal">These values are available for both
the training data as shown above and for the test data as well. See the
class ec.gep.GEPDependentVariable.<br>


</p>


<br>


<br>


</div>


</body></html>